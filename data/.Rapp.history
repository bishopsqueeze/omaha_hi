b[1:10,1:10]
5*4/2
tmp
tmp[1,]
get.edge(tmp,1)
calcSimilarityMatrix <- function(myIgraph)#
{#
    edges       <- get.data.frame(myIgraph, what="edges")#
    edges.num   <- nrow(edges)#
    edges.perm  <- combs(1:edges.num,2)#
    #sim         <- vector("numeric",length=nrow(edges.perm))#
    sim         <- matrix(0,nrow=edges.num, ncol=edges.num)#
    for (i in 1:edges.num) {#
        for (j in 1:edges.num) {#
            ## get the sample edges#
            ei  <- get.edge(myIgraph,id=i)#
            ej  <- get.edge(myIgraph,id=j)#
            ## keystone#
            keystone <- -1#
            if (ei[1] == ej[1]) {#
                keystone <- ei[1]#
                tmp.i    <- ei[2]#
                tmp.j    <- ej[2]#
            } else if (ei[1]==ej[2]) {#
                keystone <- ei[1]#
                tmp.i    <- ei[2]#
                tmp.j    <- ej[1]#
            } else if (ei[2]==ej[1]) {#
                keystone <- ei[2]#
                tmp.i    <- ei[1]#
                tmp.j    <- ej[2]#
            } else if (ei[2]==ej[2]) {#
                keystone <- ei[2]#
                tmp.i    <- ei[1]#
                tmp.j    <- ej[1]#
            }#
            if (!(keystone == -1)) {#
                np_i     <- c(keystone, tmp.i, neighbors(myIgraph, tmp.i))#
                np_j     <- c(keystone, tmp.j, neighbors(myIgraph, tmp.j))#
                sim[i] <- (length(intersect(np_i, np_j))) / (length(union(np_i, np_j)))## + 0.000001*runif(1)#
            }#
        }#
    }#
    return(sim)#
}#
tmp <- graph.data.frame(rbind(  c(1,3),c(1,2),c(2,4),#
                                c(2,5),c(2,6),c(2,7),#
                                c(2,8),c(2,9),c(2,10),#
                                c(3,8),c(3,9),c(3,10),#
                                c(3,11),c(3,12)), directed=FALSE)#
tmp <- graph.data.frame(rbind(c(1,3),c(1,2),c(2,3)), directed=FALSE)#
#
b <- calcSimilarityMatrix(a)
b[1:10,1:10]
calcSimilarityMatrix <- function(myIgraph)#
{#
    edges       <- get.data.frame(myIgraph, what="edges")#
    edges.num   <- nrow(edges)#
    edges.perm  <- combs(1:edges.num,2)#
    #sim         <- vector("numeric",length=nrow(edges.perm))#
    sim         <- matrix(0,nrow=edges.num, ncol=edges.num)#
    for (i in 1:edges.num) {#
        for (j in 1:edges.num) {#
            ## get the sample edges#
            ei  <- get.edge(myIgraph,id=i)#
            ej  <- get.edge(myIgraph,id=j)#
            ## keystone#
            keystone <- -1#
            if (ei[1] == ej[1]) {#
                keystone <- ei[1]#
                tmp.i    <- ei[2]#
                tmp.j    <- ej[2]#
            } else if (ei[1]==ej[2]) {#
                keystone <- ei[1]#
                tmp.i    <- ei[2]#
                tmp.j    <- ej[1]#
            } else if (ei[2]==ej[1]) {#
                keystone <- ei[2]#
                tmp.i    <- ei[1]#
                tmp.j    <- ej[2]#
            } else if (ei[2]==ej[2]) {#
                keystone <- ei[2]#
                tmp.i    <- ei[1]#
                tmp.j    <- ej[1]#
            }#
            if (!(keystone == -1)) {#
                np_i     <- c(keystone, tmp.i, neighbors(myIgraph, tmp.i))#
                np_j     <- c(keystone, tmp.j, neighbors(myIgraph, tmp.j))#
                sim[i,j] <- (length(intersect(np_i, np_j))) / (length(union(np_i, np_j)))## + 0.000001*runif(1)#
            }#
        }#
    }#
    return(sim)#
}#
tmp <- graph.data.frame(rbind(  c(1,3),c(1,2),c(2,4),#
                                c(2,5),c(2,6),c(2,7),#
                                c(2,8),c(2,9),c(2,10),#
                                c(3,8),c(3,9),c(3,10),#
                                c(3,11),c(3,12)), directed=FALSE)#
tmp <- graph.data.frame(rbind(c(1,3),c(1,2),c(2,3)), directed=FALSE)#
#
b <- calcSimilarityMatrix(a)
b[1:10,1:10]
bd<-1-b
bd
d <- as.dist(b)#
m <- hclust(d, method="single")
plot(m)
m$height
d <- as.dist(1-b)#
m <- hclust(d, method="single")
m
plot(m)
m$height
## similar data from linkcomm() ???#
lc <- getLinkCommunities(tmp.lm, hcmethod="single")
lc$hclust$height
q)()
q()
##------------------------------------------------------------------#
## Load libraries#
##------------------------------------------------------------------#
library(igraph)                 ## contains graph functions#
library(linkcomm)               ## contains link community functions#
library(dendextend)             ## contains dendrogram functions#
library(caTools)#
librart(gdata)#
#
##------------------------------------------------------------------#
## Clear the workspace#
##------------------------------------------------------------------#
rm(list=ls())#
#
##------------------------------------------------------------------#
## Load utility functions#
##------------------------------------------------------------------#
source("/Users/alexstephens/Development/kaggle/social_circle/k_soc/00_Utilities.r")#
##------------------------------------------------------------------#
## Benchmark: Les Miserables characters connected graph#
##------------------------------------------------------------------#
#
## load the raw dataset (from linkcomm())#
lm <- lesmiserables#
#
##------------------------------------------------------------------#
## Step 1:  This is somewhat redundant, but translate the Les Mis#
## factor/edge list into the egonet structure that I've loaded#
## from the kaggle competition.#
##------------------------------------------------------------------#
#
## convert the data of factors into characters#
tmp.lm <- convert.magic(lm, c("V1","V2"), c("character","character"))#
#
## map character names to integers#
nodes_l.uniq    <- unique(tmp.lm$V1)#
nodes_r.uniq    <- unique(tmp.lm$V2)#
characters.uniq <- union(nodes_l.uniq, nodes_r.uniq)#
characters.ids  <- 1:length(characters.uniq)#
#
## define the egonet#
lm.egonet  <- list()#
#
## load the egonet#
for (i in 1:length(nodes_l.uniq)) {#
    ## get a vertex & assign an id#
    tmp.node    <- nodes_l.uniq[i]#
    tmp.id      <- characters.ids[ which(characters.uniq == tmp.node)]#
    char.id     <- paste("ID_",tmp.id,sep="")#
    ## get the list of characters (and their ids) associated with this vertex#
    lm.egonet[[char.id]] <- paste("ID_", characters.ids[ which(characters.uniq %in% tmp.lm$V2[which(tmp.lm$V1 == tmp.node)]) ], sep="")#
}#
#
##------------------------------------------------------------------#
## Step 2:  At this point, the Les Mis data are in a format that#
## is similar to the loaded kaggle data format. Load the raw data#
## into an igraph object#
##------------------------------------------------------------------#
lm.igraph   <- convEgonetListToIgraphObject(lm.egonet)#
##------------------------------------------------------------------#
## Step 3:  Compute the dissimilarity measure amongst the clusters.#
## The similarity measure is the Jaccard coefficient. The Jaccard#
## *distance* is 1 minus the Jaccard coefficient.#
##------------------------------------------------------------------#
#
lm.sim      <- calcSimilarityMatrix(lm.igraph)  ## similarity matrix#
lm.dis      <- 1 - lm.sim                       ## jaccard distance#
#
##------------------------------------------------------------------#
## Step 3:  Compute the cluster#
##------------------------------------------------------------------#
#
## create a distance object from the dissimilarity matrix#
lm.dist     <- as.dist(lm.dis)#
#
## compute a cluster#
lm.clust    <- hclust(lm.dist, method="single")#
lm.dend     <- as.dendrogram(lm.clust)#
##------------------------------------------------------------------#
## Step 4:  Verify cluster output using linkcomm() [ok]#
##------------------------------------------------------------------#
#
## use linkcomm() to compute the cluster#
lm.lc       <- getLinkCommunities(get.data.frame(lm.igraph,"edges"), hcmethod="single")#
comp.clust  <- cbind(lm.lc$hclust$height, lm.clust$height, lm.lc$hclust$height-lm.clust$height)#
##------------------------------------------------------------------#
## Step 4:  Verify cluster output using linkcomm() [ok]#
##------------------------------------------------------------------#
#
hh <- unique(round(lm.clust$height, digits = 5)) # Round to 5 digits to prevent numerical instability affecting community formation.#
#
## just counts the number of edges at each height#
## number of heights = 50#
## sum of countClusters = 253 = distance lenght#
countClusters <- function(x, ht)#
{#
    return(length(which(ht==x)))#
}#
clusnums <- sapply(hh, countClusters, ht = round(lm.clust$height, digits = 5)) # Number of clusters at each height.#
#
## want to find the "optimal" height using the cluster density#
#for (i in 1:length(unique(lm.clust$height))) {#
    tmp.height  <- unique(lm.clust$height)[20]#
    tmp.clus    <-  cutree(lm.clust, h=tmp.height)#
#}#
## define a matrix to hold cluster membership at each height#
hgts        <- unique(lm.clust$height)#
hgts.num    <- length(hgts)#
edges.num   <- nrow(get.edgelist(lm.igraph))#
#
## define & load the matrix#
tmp.mat <- matrix(0, nrow=edges.num, ncol=hgts.num)#
for (i in 1:hgts.num) {#
    tmp.mat[,i] <- as.vector(cutree(lm.clust, h=hgts[i]))#
}#
#
## get the number of groups at each height#
groups.vec <- vector(, length=hgts.num)#
for (i in 1:hgts.num) {#
    groups.vec[i] <- length(unique(tmp.mat[,i]))#
}
for (i in 1:hgts.num) {#
    groups.uniq <- unique(tmp.mat[,i])#
    groups.num  <- length(groups.uniq)#
#
    for (j in 1:groups.num) {#
        tmp.idx     <- which(tmp.mat[,i] == groups.num[j])#
        tmp.memb    <- union(get.edgelist(lm.igraph)[tmp.idx,1], get.edgelist(lm.igraph)[tmp.idx,2])#
    }#
    ## NEXT STEP IS TO REVIEW THE DENSITY FORMULA WITH A CLEAR HEAD#
}
tmp.memb
tmp.mat
i
tmp.idx
tmp.memb
length(tmp.memb)
tmp.idx
length(tmp.idx)
## loop over each height and then the groups#
dens.vec    <- vector(, length=hgts.num)#
#
for (i in 1:hgts.num) {#
    groups.uniq <- unique(tmp.mat[,i])#
    groups.num  <- length(groups.uniq)#
#
    tmp.dens <- 0#
    for (j in 1:groups.num) {#
        tmp.idx     <- which(tmp.mat[,i] == groups.num[j])#
        tmp.memb    <- union(get.edgelist(lm.igraph)[tmp.idx,1], get.edgelist(lm.igraph)[tmp.idx,2])#
        tmp.mc      <- length(tmp.idx)#
        tmp.nc      <- length(tmp.memb)#
        if (nc > 2) {#
            tmp.dens    <- tmp.dens + 2*(tmp.mc - (tmp.nc-1))/(edges.num*(tmp.nc-2)*(tmp.nc-1))#
        }#
    }#
    dens.vec[i] <- tmp.dens#
    ## NEXT STEP IS TO REVIEW THE DENSITY FORMULA WITH A CLEAR HEAD#
}
## loop over each height and then the groups#
dens.vec    <- vector(, length=hgts.num)#
#
for (i in 1:hgts.num) {#
    groups.uniq <- unique(tmp.mat[,i])#
    groups.num  <- length(groups.uniq)#
#
    tmp.dens <- 0#
    for (j in 1:groups.num) {#
        tmp.idx     <- which(tmp.mat[,i] == groups.num[j])#
        tmp.memb    <- union(get.edgelist(lm.igraph)[tmp.idx,1], get.edgelist(lm.igraph)[tmp.idx,2])#
        tmp.mc      <- length(tmp.idx)#
        tmp.nc      <- length(tmp.memb)#
        if (tmp.nc > 2) {#
            tmp.dens    <- tmp.dens + 2*(tmp.mc - (tmp.nc-1))/(edges.num*(tmp.nc-2)*(tmp.nc-1))#
        }#
    }#
    dens.vec[i] <- tmp.dens#
    ## NEXT STEP IS TO REVIEW THE DENSITY FORMULA WITH A CLEAR HEAD#
}
dens.vec
j
i <- 38
groups.uniq <- unique(tmp.mat[,i])#
    groups.num  <- length(groups.uniq)
groups.uniq
groups.num
table(tmp.mat[,i])
i <- 1
i <- 38
j <- 1
tmp.idx     <- which(tmp.mat[,i] == groups.num[j])#
        tmp.memb    <- union(get.edgelist(lm.igraph)[tmp.idx,1], get.edgelist(lm.igraph)[tmp.idx,2])
tmp.idx
groups.uniq
tmp.idx     <- which(tmp.mat[,i] == groups.uniq[j])#
        tmp.memb    <- union(get.edgelist(lm.igraph)[tmp.idx,1], get.edgelist(lm.igraph)[tmp.idx,2])#
        tmp.mc      <- length(tmp.idx)#
        tmp.nc      <- length(tmp.memb)
tmp.idx
tmp.memb
tmp.mc
tmp.nc
2*(tmp.mc - (tmp.nc-1))/(edges.num*(tmp.nc-2)*(tmp.nc-1))
edges.num
## loop over each height and then the groups#
dens.vec    <- vector(, length=hgts.num)#
#
for (i in 1:hgts.num) {#
    groups.uniq <- unique(tmp.mat[,i])#
    groups.num  <- length(groups.uniq)#
#
    tmp.dens <- 0#
    for (j in 1:groups.num) {#
        tmp.idx     <- which(tmp.mat[,i] == groups.uniq[j])#
        tmp.memb    <- union(get.edgelist(lm.igraph)[tmp.idx,1], get.edgelist(lm.igraph)[tmp.idx,2])#
        tmp.mc      <- length(tmp.idx)#
        tmp.nc      <- length(tmp.memb)#
        if (tmp.nc > 2) {#
            tmp.dens    <- tmp.dens + 2*(tmp.mc - (tmp.nc-1))/(edges.num*(tmp.nc-2)*(tmp.nc-1))#
        }#
    }#
    dens.vec[i] <- tmp.dens#
    ## NEXT STEP IS TO REVIEW THE DENSITY FORMULA WITH A CLEAR HEAD#
}
dens.vec
plot(dens.vec)
plot(dens.vec, type="b")
## loop over each height and then the groups#
dens.vec    <- vector(, length=hgts.num)#
#
for (i in 1:hgts.num) {#
    groups.uniq <- unique(tmp.mat[,i])#
    groups.num  <- length(groups.uniq)#
#
    tmp.dens <- 0#
    for (j in 1:groups.num) {#
        tmp.idx     <- which(tmp.mat[,i] == groups.uniq[j])#
        tmp.memb    <- union(get.edgelist(lm.igraph)[tmp.idx,1], get.edgelist(lm.igraph)[tmp.idx,2])#
        tmp.mc      <- length(tmp.idx)#
        tmp.nc      <- length(tmp.memb)#
        if (tmp.nc > 2) {#
            tmp.dens    <- tmp.dens + 2*tmp.mc*(tmp.mc - (tmp.nc-1))/(edges.num*(tmp.nc-2)*(tmp.nc-1))#
        }#
    }#
    dens.vec[i] <- tmp.dens#
    ## NEXT STEP IS TO REVIEW THE DENSITY FORMULA WITH A CLEAR HEAD#
}
tmp.dens
dens.vec
plot(tmp.vec)
plot(dens.vec)
i
max(dens.vec)
edges.num
lm.lc$pdens
## loop over each height and then the groups#
dens.vec    <- vector(, length=hgts.num)#
for (i in 1:hgts.num) {#
    groups.uniq <- unique(tmp.mat[,i])#
    groups.num  <- length(groups.uniq)#
#
    tmp.dens <- 0#
    for (j in 1:groups.num) {#
        tmp.idx     <- which(tmp.mat[,i] == groups.uniq[j])#
        tmp.memb    <- union(get.edgelist(lm.igraph)[tmp.idx,1], get.edgelist(lm.igraph)[tmp.idx,2])#
        tmp.mc      <- length(tmp.idx)#
        tmp.nc      <- length(tmp.memb)#
        if (tmp.nc > 2) {#
            tmp.dens    <- tmp.dens + 2*tmp.mc*(tmp.mc - (tmp.nc-1))/(edges.num*(tmp.nc-2)*(tmp.nc-1))#
        }#
    }#
    dens.vec[i] <- c(0, tmp.dens)#
    ## NEXT STEP IS TO REVIEW THE DENSITY FORMULA WITH A CLEAR HEAD#
}
## loop over each height and then the groups#
dens.vec    <- vector(, length=hgts.num)#
for (i in 1:hgts.num) {#
    groups.uniq <- unique(tmp.mat[,i])#
    groups.num  <- length(groups.uniq)#
#
    tmp.dens <- 0#
    for (j in 1:groups.num) {#
        tmp.idx     <- which(tmp.mat[,i] == groups.uniq[j])#
        tmp.memb    <- union(get.edgelist(lm.igraph)[tmp.idx,1], get.edgelist(lm.igraph)[tmp.idx,2])#
        tmp.mc      <- length(tmp.idx)#
        tmp.nc      <- length(tmp.memb)#
        if (tmp.nc > 2) {#
            tmp.dens    <- tmp.dens + 2*tmp.mc*(tmp.mc - (tmp.nc-1))/(edges.num*(tmp.nc-2)*(tmp.nc-1))#
        }#
    }#
    dens.vec[i] <- tmp.dens#
    ## NEXT STEP IS TO REVIEW THE DENSITY FORMULA WITH A CLEAR HEAD#
}
length(dens.vec)
hgts
length(hgts)
cbind(hgts, dens.vec)
lm.lc$pdens
cbind(hgts, dens.vec, lm.lc$pdens)
hgts
cbind(hgts, dens.vec, lm.lc$pdens[-1,])
calcPartitionDensity    <- function(myHclust, myIgraph)#
{#
    h.vec   <- unique(myHclust$height)#
    h.num   <- length(h)#
    e.num   <- nrow(get.edgelist(myIgraph))#
    ## matrix to hold the identify of group members at each height#
    clust.mat   <- matrix(0, nrow=e.num, ncol=h.num)#
    dens.vec    <- vector(, length=h.num)#
#
    ## loop each height and compute the partition density#
    for (i in 1:h.num) {#
        tmp.mat[,i]   <- as.vector(cutree(lm.clust, h=hgts[i]))#
        groups.uniq   <- unique(tmp.mat[,i])#
        groups.num    <- length(groups.uniq)#
        tmp.dens      <- 0#
        ## loop over all groups at a height and compute the density#
        for (j in 1:groups.num) {#
           ## identify location of the group memebers#
           tmp.idx     <- which(tmp.mat[,i] == groups.uniq[j])#
           tmp.memb    <- union(get.edgelist(lm.igraph)[tmp.idx,1], get.edgelist(lm.igraph)[tmp.idx,2])#
           ## compute the number of nodes and edges in the group#
           tmp.mc      <- length(tmp.idx)#
           tmp.nc      <- length(tmp.memb)#
           ## by convention, clusers with two nodes has a density of 0#
           if (tmp.nc > 2) {#
               tmp.dens    <- tmp.dens + 2*tmp.mc*(tmp.mc - (tmp.nc-1))/(e.num*(tmp.nc-2)*(tmp.nc-1))#
           }#
        }#
        dens.vec[i] <- tmp.dens#
#
    }#
    return(data.frame(h=h.vec, den=dens.vec))#
}
lm.clust
lm.igraph
a <- calcPartitionDensity(lm.clust, lm.igraph)
calcPartitionDensity    <- function(myHclust, myIgraph)#
{#
    h.vec   <- unique(myHclust$height)#
    h.num   <- length(h.vec)#
    e.num   <- nrow(get.edgelist(myIgraph))#
    ## matrix to hold the identify of group members at each height#
    clust.mat   <- matrix(0, nrow=e.num, ncol=h.num)#
    dens.vec    <- vector(, length=h.num)#
#
    ## loop each height and compute the partition density#
    for (i in 1:h.num) {#
        tmp.mat[,i]   <- as.vector(cutree(lm.clust, h=hgts[i]))#
        groups.uniq   <- unique(tmp.mat[,i])#
        groups.num    <- length(groups.uniq)#
        tmp.dens      <- 0#
        ## loop over all groups at a height and compute the density#
        for (j in 1:groups.num) {#
           ## identify location of the group memebers#
           tmp.idx     <- which(tmp.mat[,i] == groups.uniq[j])#
           tmp.memb    <- union(get.edgelist(lm.igraph)[tmp.idx,1], get.edgelist(lm.igraph)[tmp.idx,2])#
           ## compute the number of nodes and edges in the group#
           tmp.mc      <- length(tmp.idx)#
           tmp.nc      <- length(tmp.memb)#
           ## by convention, clusers with two nodes has a density of 0#
           if (tmp.nc > 2) {#
               tmp.dens    <- tmp.dens + 2*tmp.mc*(tmp.mc - (tmp.nc-1))/(e.num*(tmp.nc-2)*(tmp.nc-1))#
           }#
        }#
        dens.vec[i] <- tmp.dens#
#
    }#
    return(data.frame(h=h.vec, den=dens.vec))#
}
a <- calcPartitionDensity(lm.clust, lm.igraph)
head(a)
plot(h)
plot(a$h, a$den)
plot(a$h, a$den, type="b")
calcPartitionDensity    <- function(myHclust, myIgraph)#
{#
    h.vec   <- unique(myHclust$height)#
    h.num   <- length(h.vec)#
    e.num   <- nrow(get.edgelist(myIgraph))#
    ## matrix to hold the identify of group members at each height#
    #clust.mat   <- matrix(0, nrow=e.num, ncol=h.num)#
    dens.vec    <- vector(, length=h.num)#
#
    ## loop each height and compute the partition density#
    for (i in 1:h.num) {#
      #tmp.mat[,i]   <- as.vector(cutree(lm.clust, h=hgts[i]))#
      #groups.uniq   <- unique(tmp.mat[,i])#
       group.uniq   <- as.vector(cutree(lm.clust, h=hgts[i]))#
        groups.num    <- length(groups.uniq)#
        tmp.dens      <- 0#
        ## loop over all groups at a height and compute the density#
        for (j in 1:groups.num) {#
           ## identify location of the group memebers#
           tmp.idx     <- which(tmp.mat[,i] == groups.uniq[j])#
           tmp.memb    <- union(get.edgelist(lm.igraph)[tmp.idx,1], get.edgelist(lm.igraph)[tmp.idx,2])#
           ## compute the number of nodes and edges in the group#
           tmp.mc      <- length(tmp.idx)#
           tmp.nc      <- length(tmp.memb)#
           ## by convention, clusers with two nodes has a density of 0#
           if (tmp.nc > 2) {#
               tmp.dens    <- tmp.dens + 2*tmp.mc*(tmp.mc - (tmp.nc-1))/(e.num*(tmp.nc-2)*(tmp.nc-1))#
           }#
        }#
        dens.vec[i] <- tmp.dens#
#
    }#
    return(data.frame(h=h.vec, den=dens.vec))#
}
a <- calcPartitionDensity(lm.clust, lm.igraph)
a
calcPartitionDensity    <- function(myHclust, myIgraph)#
{#
    h.vec   <- unique(myHclust$height)#
    h.num   <- length(h.vec)#
    e.num   <- nrow(get.edgelist(myIgraph))#
    ## matrix to hold the identify of group members at each height#
    clust.vec   <- matrix(, length=h.num)#
    dens.vec    <- vector(, length=h.num)#
#
    ## loop each height and compute the partition density#
    for (i in 1:h.num) {#
      #tmp.mat[,i]   <- as.vector(cutree(lm.clust, h=hgts[i]))#
      #groups.uniq   <- unique(tmp.mat[,i])#
      clust.vec <- as.vector(cutree(lm.clust, h=hgts[i]))#
      groups.uniq   <- unique(clust.vec)#
        groups.num    <- length(groups.uniq)#
        tmp.dens      <- 0#
        ## loop over all groups at a height and compute the density#
        for (j in 1:groups.num) {#
           ## identify location of the group memebers#
           tmp.idx     <- which(clust.vec == groups.uniq[j])#
           tmp.memb    <- union(get.edgelist(lm.igraph)[tmp.idx,1], get.edgelist(lm.igraph)[tmp.idx,2])#
           ## compute the number of nodes and edges in the group#
           tmp.mc      <- length(tmp.idx)#
           tmp.nc      <- length(tmp.memb)#
           ## by convention, clusers with two nodes has a density of 0#
           if (tmp.nc > 2) {#
               tmp.dens    <- tmp.dens + 2*tmp.mc*(tmp.mc - (tmp.nc-1))/(e.num*(tmp.nc-2)*(tmp.nc-1))#
           }#
        }#
        dens.vec[i] <- tmp.dens#
#
    }#
    return(data.frame(h=h.vec, den=dens.vec))#
}
a <- calcPartitionDensity(lm.clust, lm.igraph)
calcPartitionDensity    <- function(myHclust, myIgraph)#
{#
    h.vec   <- unique(myHclust$height)#
    h.num   <- length(h.vec)#
    e.num   <- nrow(get.edgelist(myIgraph))#
    ## matrix to hold the identify of group members at each height#
    clust.vec   <- vector(, length=h.num)#
    dens.vec    <- vector(, length=h.num)#
#
    ## loop each height and compute the partition density#
    for (i in 1:h.num) {#
      #tmp.mat[,i]   <- as.vector(cutree(lm.clust, h=hgts[i]))#
      #groups.uniq   <- unique(tmp.mat[,i])#
      clust.vec <- as.vector(cutree(lm.clust, h=hgts[i]))#
      groups.uniq   <- unique(clust.vec)#
        groups.num    <- length(groups.uniq)#
        tmp.dens      <- 0#
        ## loop over all groups at a height and compute the density#
        for (j in 1:groups.num) {#
           ## identify location of the group memebers#
           tmp.idx     <- which(clust.vec == groups.uniq[j])#
           tmp.memb    <- union(get.edgelist(lm.igraph)[tmp.idx,1], get.edgelist(lm.igraph)[tmp.idx,2])#
           ## compute the number of nodes and edges in the group#
           tmp.mc      <- length(tmp.idx)#
           tmp.nc      <- length(tmp.memb)#
           ## by convention, clusers with two nodes has a density of 0#
           if (tmp.nc > 2) {#
               tmp.dens    <- tmp.dens + 2*tmp.mc*(tmp.mc - (tmp.nc-1))/(e.num*(tmp.nc-2)*(tmp.nc-1))#
           }#
        }#
        dens.vec[i] <- tmp.dens#
#
    }#
    return(data.frame(h=h.vec, den=dens.vec))#
}
a <- calcPartitionDensity(lm.clust, lm.igraph)
a
plot(a$h, a$den, type="b")
##------------------------------------------------------------------#
## Clear the workspace#
##------------------------------------------------------------------#
rm(list=ls())#
#
##------------------------------------------------------------------#
## Load utility functions#
##------------------------------------------------------------------#
source("/Users/alexstephens/Development/kaggle/social_circle/k_soc/00_Utilities.r")#
##------------------------------------------------------------------#
## Benchmark: Les Miserables characters connected graph#
##------------------------------------------------------------------#
#
## load the raw dataset (from linkcomm())#
lm <- lesmiserables#
#
##------------------------------------------------------------------#
## Step 1:  This is somewhat redundant, but translate the Les Mis#
## factor/edge list into the egonet structure that I've loaded#
## from the kaggle competition.#
##------------------------------------------------------------------#
#
## convert the data of factors into characters#
tmp.lm <- convert.magic(lm, c("V1","V2"), c("character","character"))#
#
## map character names to integers#
nodes_l.uniq    <- unique(tmp.lm$V1)#
nodes_r.uniq    <- unique(tmp.lm$V2)#
characters.uniq <- union(nodes_l.uniq, nodes_r.uniq)#
characters.ids  <- 1:length(characters.uniq)#
#
## define the egonet#
lm.egonet  <- list()#
#
## load the egonet#
for (i in 1:length(nodes_l.uniq)) {#
    ## get a vertex & assign an id#
    tmp.node    <- nodes_l.uniq[i]#
    tmp.id      <- characters.ids[ which(characters.uniq == tmp.node)]#
    char.id     <- paste("ID_",tmp.id,sep="")#
    ## get the list of characters (and their ids) associated with this vertex#
    lm.egonet[[char.id]] <- paste("ID_", characters.ids[ which(characters.uniq %in% tmp.lm$V2[which(tmp.lm$V1 == tmp.node)]) ], sep="")#
}#
#
##------------------------------------------------------------------#
## Step 2:  At this point, the Les Mis data are in a format that#
## is similar to the loaded kaggle data format. Load the raw data#
## into an igraph object#
##------------------------------------------------------------------#
lm.igraph   <- convEgonetListToIgraphObject(lm.egonet)#
##------------------------------------------------------------------#
## Step 3:  Compute the dissimilarity measure amongst the clusters.#
## The similarity measure is the Jaccard coefficient. The Jaccard#
## *distance* is 1 minus the Jaccard coefficient.#
##------------------------------------------------------------------#
#
lm.sim      <- calcSimilarityMatrix(lm.igraph)  ## similarity matrix#
lm.dis      <- 1 - lm.sim                       ## jaccard distance#
#
##------------------------------------------------------------------#
## Step 3:  Compute the cluster#
##------------------------------------------------------------------#
#
## create a distance object from the dissimilarity matrix#
lm.dist     <- as.dist(lm.dis)#
#
## compute a cluster#
lm.clust    <- hclust(lm.dist, method="single")#
lm.dend     <- as.dendrogram(lm.clust)#
##------------------------------------------------------------------#
## Step 4:  Verify cluster output using linkcomm() [ok]#
##------------------------------------------------------------------
calcPartitionDensity    <- function(myHclust, myIgraph)#
{#
    h.vec       <- unique(myHclust$height)#
    h.num       <- length(h.vec)#
    e.num       <- nrow(get.edgelist(myIgraph))#
    ## matrix to hold the identify of group members at each height#
    clust.vec   <- vector(, length=h.num)#
    dens.vec    <- vector(, length=h.num)#
#
    ## loop each height and compute the partition density#
    for (i in 1:h.num) {#
        clust.vec     <- as.vector(cutree(lm.clust, h=h.vec[i]))#
        groups.uniq   <- unique(clust.vec)#
        groups.num    <- length(groups.uniq)#
        tmp.dens      <- 0#
        ## loop over all groups at a height and compute the density#
        for (j in 1:groups.num) {#
           ## identify location of the group memebers#
           tmp.idx     <- which(clust.vec == groups.uniq[j])#
           tmp.memb    <- union(get.edgelist(lm.igraph)[tmp.idx,1], get.edgelist(lm.igraph)[tmp.idx,2])#
           ## compute the number of nodes and edges in the group#
           tmp.mc      <- length(tmp.idx)#
           tmp.nc      <- length(tmp.memb)#
           ## by convention, clusers with two nodes has a density of 0#
           if (tmp.nc > 2) {#
               tmp.dens    <- tmp.dens + 2*tmp.mc*(tmp.mc - (tmp.nc-1))/(e.num*(tmp.nc-2)*(tmp.nc-1))#
           }#
        }#
        dens.vec[i] <- tmp.dens#
#
    }#
    return(data.frame(h=h.vec, den=dens.vec))#
}
a <- calcPartitionDensity(lm.clust, lm.igraph)
a
plot(a$h, a$den)
##------------------------------------------------------------------#
## The purpose of this script is to re-create an example set of#
## clusters.  The example (the Les Miserables characters) set of#
## edges is taken from Ahn, and there is an R package that will#
## reproduce that results (linkcomm()).  I want to reproduce it#
## as well because I will be modifying the basic result (i.e.,#
## a similarity matrix to reproduce the Ye [?] et al. paper.#
##------------------------------------------------------------------#
#
##------------------------------------------------------------------#
## Load libraries#
##------------------------------------------------------------------#
library(igraph)                 ## contains graph functions#
library(linkcomm)               ## contains link community functions#
library(dendextend)             ## contains dendrogram functions#
library(caTools)#
librart(gdata)#
#
##------------------------------------------------------------------#
## Clear the workspace#
##------------------------------------------------------------------#
rm(list=ls())#
#
##------------------------------------------------------------------#
## Load utility functions#
##------------------------------------------------------------------#
source("/Users/alexstephens/Development/kaggle/social_circle/k_soc/00_Utilities.r")#
##------------------------------------------------------------------#
## Benchmark: Les Miserables characters connected graph#
##------------------------------------------------------------------#
#
## load the raw dataset (from linkcomm())#
lm <- lesmiserables#
#
##------------------------------------------------------------------#
## Step 1:  This is somewhat redundant, but translate the Les Mis#
## factor/edge list into the egonet structure that I've loaded#
## from the kaggle competition.#
##------------------------------------------------------------------#
#
## convert the data of factors into characters#
tmp.lm <- convert.magic(lm, c("V1","V2"), c("character","character"))#
#
## map character names to integers#
nodes_l.uniq    <- unique(tmp.lm$V1)#
nodes_r.uniq    <- unique(tmp.lm$V2)#
characters.uniq <- union(nodes_l.uniq, nodes_r.uniq)#
characters.ids  <- 1:length(characters.uniq)#
#
## define the egonet#
lm.egonet  <- list()#
#
## load the egonet#
for (i in 1:length(nodes_l.uniq)) {#
    ## get a vertex & assign an id#
    tmp.node    <- nodes_l.uniq[i]#
    tmp.id      <- characters.ids[ which(characters.uniq == tmp.node)]#
    char.id     <- paste("ID_",tmp.id,sep="")#
    ## get the list of characters (and their ids) associated with this vertex#
    lm.egonet[[char.id]] <- paste("ID_", characters.ids[ which(characters.uniq %in% tmp.lm$V2[which(tmp.lm$V1 == tmp.node)]) ], sep="")#
}#
#
##------------------------------------------------------------------#
## Step 2:  At this point, the Les Mis data are in a format that#
## is similar to the loaded kaggle data format. Load the raw data#
## into an igraph object#
##------------------------------------------------------------------#
lm.igraph   <- convEgonetListToIgraphObject(lm.egonet)#
##------------------------------------------------------------------#
## Step 3:  Compute the dissimilarity measure amongst the clusters.#
## The similarity measure is the Jaccard coefficient. The Jaccard#
## *distance* is 1 minus the Jaccard coefficient.#
##------------------------------------------------------------------#
#
lm.sim      <- calcSimilarityMatrix(lm.igraph)  ## similarity matrix#
lm.dis      <- 1 - lm.sim                       ## jaccard distance#
#
##------------------------------------------------------------------#
## Step 3:  Compute the cluster#
##------------------------------------------------------------------#
#
## create a distance object from the dissimilarity matrix#
lm.dist     <- as.dist(lm.dis)#
#
## compute a cluster#
lm.clust    <- hclust(lm.dist, method="single")#
lm.dend     <- as.dendrogram(lm.clust)#
##------------------------------------------------------------------#
## Step 4:  Verify cluster output using linkcomm() [ok]#
##------------------------------------------------------------------#
#
## use linkcomm() to compute the cluster#
lm.lc       <- getLinkCommunities(get.data.frame(lm.igraph,"edges"), hcmethod="single")#
comp.clust  <- cbind(lm.lc$hclust$height, lm.clust$height, lm.lc$hclust$height-lm.clust$height)
lm.lc$clusters
lapply(lm.lc$clusters, length)
sum(unlist(lapply(lm.lc$clusters, length)))
calcPartitionDensity    <- function(myHclust, myIgraph)#
{#
    h.vec       <- unique(myHclust$height)#
    h.num       <- length(h.vec)#
    e.num       <- nrow(get.edgelist(myIgraph))#
    ## matrix to hold the identify of group members at each height#
    clust.vec   <- vector(, length=h.num)#
    dens.vec    <- vector(, length=h.num)#
    ## loop each height and compute the partition density#
    for (i in 1:h.num) {#
        clust.vec     <- as.vector(cutree(myHclust, h=h.vec[i]))#
        groups.uniq   <- unique(clust.vec)#
        groups.num    <- length(groups.uniq)#
        tmp.dens      <- 0#
        ## loop over all groups at a height and compute the density#
        for (j in 1:groups.num) {#
            ## identify location of the group memebers#
            tmp.idx     <- which(clust.vec == groups.uniq[j])#
            tmp.memb    <- union(get.edgelist(myIgraph)[tmp.idx,1], get.edgelist(myIgraph)[tmp.idx,2])#
            ## compute the number of nodes and edges in the group#
            tmp.mc      <- length(tmp.idx)#
            tmp.nc      <- length(tmp.memb)#
            ## by convention, clusers with two nodes has a density of 0#
            if (tmp.nc > 2) {#
                tmp.dens    <- tmp.dens + 2*tmp.mc*(tmp.mc - (tmp.nc-1))/(e.num*(tmp.nc-2)*(tmp.nc-1))#
            }#
        }#
        dens.vec[i] <- tmp.dens#
    }#
    ## accumulate results#
    pdens   <- data.frame(h=h.vec, den=dens.vec)#
    pdmax   <- max(dens.vec)#
    hmax    <- h.vec[dens.vec == pdmax]#
    cmax    <- cutree(myHclust, h=h.vec[i])#
    return(list(pdens, pdmax, hmax, cmax))#
}
lm.dens <- calcParitionDensity(lm.clust, lm.igraph)
lm.dens <- calcPartitionDensity(lm.clust, lm.igraph)
lm.dens
calcPartitionDensity    <- function(myHclust, myIgraph)#
{#
    h.vec       <- unique(myHclust$height)#
    h.num       <- length(h.vec)#
    e.num       <- nrow(get.edgelist(myIgraph))#
    ## matrix to hold the identify of group members at each height#
    clust.vec   <- vector(, length=h.num)#
    dens.vec    <- vector(, length=h.num)#
    ## loop each height and compute the partition density#
    for (i in 1:h.num) {#
        clust.vec     <- as.vector(cutree(myHclust, h=h.vec[i]))#
        groups.uniq   <- unique(clust.vec)#
        groups.num    <- length(groups.uniq)#
        tmp.dens      <- 0#
        ## loop over all groups at a height and compute the density#
        for (j in 1:groups.num) {#
            ## identify location of the group memebers#
            tmp.idx     <- which(clust.vec == groups.uniq[j])#
            tmp.memb    <- union(get.edgelist(myIgraph)[tmp.idx,1], get.edgelist(myIgraph)[tmp.idx,2])#
            ## compute the number of nodes and edges in the group#
            tmp.mc      <- length(tmp.idx)#
            tmp.nc      <- length(tmp.memb)#
            ## by convention, clusers with two nodes has a density of 0#
            if (tmp.nc > 2) {#
                tmp.dens    <- tmp.dens + 2*tmp.mc*(tmp.mc - (tmp.nc-1))/(e.num*(tmp.nc-2)*(tmp.nc-1))#
            }#
        }#
        dens.vec[i] <- tmp.dens#
    }#
    ## accumulate results#
    pdens   <- data.frame(h=h.vec, den=dens.vec)#
    pdmax   <- max(dens.vec)#
    hmax    <- h.vec[dens.vec == pdmax]#
    cmax    <- cutree(myHclust, h=hmax)#
    return(list(pdens, pdmax, hmax, cmax))#
}
lm.dens <- calcPartitionDensity(lm.clust, lm.igraph)
lm.dens
table(lm.dens[[4]])
calcPartitionDensity    <- function(myHclust, myIgraph)#
{#
    h.vec       <- unique(myHclust$height)#
    h.num       <- length(h.vec)#
    e.num       <- nrow(get.edgelist(myIgraph))#
    ## matrix to hold the identify of group members at each height#
    clust.vec   <- vector(, length=h.num)#
    dens.vec    <- vector(, length=h.num)#
    ## loop each height and compute the partition density#
    for (i in 1:h.num) {#
        clust.vec     <- as.vector(cutree(myHclust, h=h.vec[i]))#
        groups.uniq   <- unique(clust.vec)#
        groups.num    <- length(groups.uniq)#
        tmp.dens      <- 0#
        ## loop over all groups at a height and compute the density#
        for (j in 1:groups.num) {#
            ## identify location of the group memebers#
            tmp.idx     <- which(clust.vec == groups.uniq[j])#
            tmp.memb    <- union(get.edgelist(myIgraph)[tmp.idx,1], get.edgelist(myIgraph)[tmp.idx,2])#
            ## compute the number of nodes and edges in the group#
            tmp.mc      <- length(tmp.idx)#
            tmp.nc      <- length(tmp.memb)#
            ## by convention, clusers with two nodes has a density of 0#
            if (tmp.nc > 2) {#
                tmp.dens    <- tmp.dens + 2*tmp.mc*(tmp.mc - (tmp.nc-1))/(e.num*(tmp.nc-2)*(tmp.nc-1))#
            }#
        }#
        dens.vec[i] <- tmp.dens#
    }#
    ## accumulate results#
    pdens   <- data.frame(h=h.vec, den=dens.vec)#
    pdmax   <- max(dens.vec)#
    hmax    <- h.vec[dens.vec == pdmax]#
    cmax    <- cutree(myHclust, h=hmax)#
    return(list(pdens=pdens, pdmax=pdmax, hmax=hmax, clust.ids=cmax))#
}#
calcPartitionDensity    <- function(myHclust, myIgraph)#
{#
    h.vec       <- unique(myHclust$height)#
    h.num       <- length(h.vec)#
    e.num       <- nrow(get.edgelist(myIgraph))#
    ## matrix to hold the identify of group members at each height#
    clust.vec   <- vector(, length=h.num)#
    dens.vec    <- vector(, length=h.num)#
    ## loop each height and compute the partition density#
    for (i in 1:h.num) {#
        clust.vec     <- as.vector(cutree(myHclust, h=h.vec[i]))#
        groups.uniq   <- unique(clust.vec)#
        groups.num    <- length(groups.uniq)#
        tmp.dens      <- 0#
        ## loop over all groups at a height and compute the density#
        for (j in 1:groups.num) {#
            ## identify location of the group memebers#
            tmp.idx     <- which(clust.vec == groups.uniq[j])#
            tmp.memb    <- union(get.edgelist(myIgraph)[tmp.idx,1], get.edgelist(myIgraph)[tmp.idx,2])#
            ## compute the number of nodes and edges in the group#
            tmp.mc      <- length(tmp.idx)#
            tmp.nc      <- length(tmp.memb)#
            ## by convention, clusers with two nodes has a density of 0#
            if (tmp.nc > 2) {#
                tmp.dens    <- tmp.dens + 2*tmp.mc*(tmp.mc - (tmp.nc-1))/(e.num*(tmp.nc-2)*(tmp.nc-1))#
            }#
        }#
        dens.vec[i] <- tmp.dens#
    }#
    ## accumulate results#
    pdens   <- data.frame(h=h.vec, den=dens.vec)#
    pdmax   <- max(dens.vec)#
    hmax    <- h.vec[dens.vec == pdmax]#
    cmax    <- cutree(myHclust, h=hmax)#
    return(list(pdens=pdens, pdmax=pdmax, hmax=hmax, clust.ids=cmax))#
}
calcPartitionDensity    <- function(myHclust, myIgraph)#
{#
    h.vec       <- unique(myHclust$height)#
    h.num       <- length(h.vec)#
    e.num       <- nrow(get.edgelist(myIgraph))#
    ## matrix to hold the identify of group members at each height#
    clust.vec   <- vector(, length=h.num)#
    dens.vec    <- vector(, length=h.num)#
    ## loop each height and compute the partition density#
    for (i in 1:h.num) {#
        clust.vec     <- as.vector(cutree(myHclust, h=h.vec[i]))#
        groups.uniq   <- unique(clust.vec)#
        groups.num    <- length(groups.uniq)#
        tmp.dens      <- 0#
        ## loop over all groups at a height and compute the density#
        for (j in 1:groups.num) {#
            ## identify location of the group memebers#
            tmp.idx     <- which(clust.vec == groups.uniq[j])#
            tmp.memb    <- union(get.edgelist(myIgraph)[tmp.idx,1], get.edgelist(myIgraph)[tmp.idx,2])#
            ## compute the number of nodes and edges in the group#
            tmp.mc      <- length(tmp.idx)#
            tmp.nc      <- length(tmp.memb)#
            ## by convention, clusers with two nodes has a density of 0#
            if (tmp.nc > 2) {#
                tmp.dens    <- tmp.dens + 2*tmp.mc*(tmp.mc - (tmp.nc-1))/(e.num*(tmp.nc-2)*(tmp.nc-1))#
            }#
        }#
        dens.vec[i] <- tmp.dens#
    }#
    ## accumulate results#
    pdens   <- data.frame(h=h.vec, den=dens.vec)#
    pdmax   <- max(dens.vec)#
    hmax    <- h.vec[dens.vec == pdmax]#
    cmax    <- cutree(myHclust, h=hmax)#
    return(list(pdens=pdens, pdmax=pdmax, hmax=hmax, clust.ids=cmax))#
}
table(lm.dens[[4]])
lm.dens <- calcPartitionDensity(lm.clust, lm.igraph)
lm.dens
lm.dens$clust.ids
table(lm.dens$clust.ids)
a <- table(lm.dens$clust.ids)
a[a>1]
length(a[a>1])
lm.lc$clusters
lm.dens$clust.ids
length(unique(lm.dens$clust.ids))
edges(get.edgelist(lm.igraph))
edges(lm.igraph)
lm.clust
lm.dens
as.vector(lm.dens$clust.ids)
as.vector(lm.dens$clust.ids) == lm.dens$clust.ids[2]
calcPartitionDensity    <- function(myHclust, myIgraph)#
{#
    h.vec       <- unique(myHclust$height)#
    h.num       <- length(h.vec)#
    e.num       <- nrow(get.edgelist(myIgraph))#
    e.idx       <- 1:e.num#
    ## matrix to hold the identify of group members at each height#
    clust.vec   <- vector(, length=h.num)#
    dens.vec    <- vector(, length=h.num)#
    ## loop each height and compute the partition density#
    for (i in 1:h.num) {#
        clust.vec     <- as.vector(cutree(myHclust, h=h.vec[i]))#
        groups.uniq   <- unique(clust.vec)#
        groups.num    <- length(groups.uniq)#
        tmp.dens      <- 0#
        ## loop over all groups at a height and compute the density#
        for (j in 1:groups.num) {#
            ## identify location of the group memebers#
            tmp.idx     <- which(clust.vec == groups.uniq[j])#
            tmp.memb    <- union(get.edgelist(myIgraph)[tmp.idx,1], get.edgelist(myIgraph)[tmp.idx,2])#
            ## compute the number of nodes and edges in the group#
            tmp.mc      <- length(tmp.idx)#
            tmp.nc      <- length(tmp.memb)#
            ## by convention, clusers with two nodes has a density of 0#
            if (tmp.nc > 2) {#
                tmp.dens    <- tmp.dens + 2*tmp.mc*(tmp.mc - (tmp.nc-1))/(e.num*(tmp.nc-2)*(tmp.nc-1))#
            }#
        }#
        dens.vec[i] <- tmp.dens#
    }#
    ## idenitfy the maximum density & corresponding height#
    pdens   <- data.frame(h=h.vec, den=dens.vec)#
    pdmax   <- max(dens.vec)#
    hmax    <- h.vec[dens.vec == pdmax]#
    ## isolate cluster memebers#
    clust.ids   <- cutree(myHclust, h=hmax)#
    clust.num   <- length(unique(clust.ids))#
    clust.list  <- list()#
    clust.cnt   <- 1#
    for (i in 1:clust.num) {#
        tmp.clust   <- clust.ids[i]#
        tmp.idx     <- which(as.vector(lm.dens$clust.ids) == tmp.clust)#
        tmp.memb    <- union(get.edgelist(myIgraph)[tmp.idx,1], get.edgelist(myIgraph)[tmp.idx,2])#
        if (length(tmp.memb) >= 3) {#
            clust.list[[clust.cnt]] <- tmp.memb#
            clust.cnt   <- clust.cnt + 1#
        }#
    }#
    return(list(pdens=pdens, pdmax=pdmax, hmax=hmax, clust.ids=cmax, clust.list=clust.list))#
}
a <- calcPartitionDensity(lm.clust, lm.igraph)
calcPartitionDensity    <- function(myHclust, myIgraph)#
{#
    h.vec       <- unique(myHclust$height)#
    h.num       <- length(h.vec)#
    e.num       <- nrow(get.edgelist(myIgraph))#
    e.idx       <- 1:e.num#
    ## matrix to hold the identify of group members at each height#
    clust.vec   <- vector(, length=h.num)#
    dens.vec    <- vector(, length=h.num)#
    ## loop each height and compute the partition density#
    for (i in 1:h.num) {#
        clust.vec     <- as.vector(cutree(myHclust, h=h.vec[i]))#
        groups.uniq   <- unique(clust.vec)#
        groups.num    <- length(groups.uniq)#
        tmp.dens      <- 0#
        ## loop over all groups at a height and compute the density#
        for (j in 1:groups.num) {#
            ## identify location of the group memebers#
            tmp.idx     <- which(clust.vec == groups.uniq[j])#
            tmp.memb    <- union(get.edgelist(myIgraph)[tmp.idx,1], get.edgelist(myIgraph)[tmp.idx,2])#
            ## compute the number of nodes and edges in the group#
            tmp.mc      <- length(tmp.idx)#
            tmp.nc      <- length(tmp.memb)#
            ## by convention, clusers with two nodes has a density of 0#
            if (tmp.nc > 2) {#
                tmp.dens    <- tmp.dens + 2*tmp.mc*(tmp.mc - (tmp.nc-1))/(e.num*(tmp.nc-2)*(tmp.nc-1))#
            }#
        }#
        dens.vec[i] <- tmp.dens#
    }#
    ## idenitfy the maximum density & corresponding height#
    pdens   <- data.frame(h=h.vec, den=dens.vec)#
    pdmax   <- max(dens.vec)#
    hmax    <- h.vec[dens.vec == pdmax]#
    ## isolate cluster memebers#
    clust.ids   <- cutree(myHclust, h=hmax)#
    clust.num   <- length(unique(clust.ids))#
    clust.list  <- list()#
    clust.cnt   <- 1#
    for (i in 1:clust.num) {#
        tmp.clust   <- clust.ids[i]#
        tmp.idx     <- which(as.vector(lm.dens$clust.ids) == tmp.clust)#
        tmp.memb    <- union(get.edgelist(myIgraph)[tmp.idx,1], get.edgelist(myIgraph)[tmp.idx,2])#
        if (length(tmp.memb) >= 3) {#
            clust.list[[clust.cnt]] <- tmp.memb#
            clust.cnt   <- clust.cnt + 1#
        }#
    }#
    return(list(pdens=pdens, pdmax=pdmax, hmax=hmax, clust.ids=clust.ids, clust.list=clust.list))#
}
a <- calcPartitionDensity(lm.clust, lm.igraph)
a
clust.ids <- cutree(lm.clust, h= 0.6363636)
clust.ids
calcPartitionDensity    <- function(myHclust, myIgraph)#
{#
    h.vec       <- unique(myHclust$height)#
    h.num       <- length(h.vec)#
    e.num       <- nrow(get.edgelist(myIgraph))#
    e.idx       <- 1:e.num#
    ## matrix to hold the identify of group members at each height#
    clust.vec   <- vector(, length=h.num)#
    dens.vec    <- vector(, length=h.num)#
    ## loop each height and compute the partition density#
    for (i in 1:h.num) {#
        clust.vec     <- as.vector(cutree(myHclust, h=h.vec[i]))#
        groups.uniq   <- unique(clust.vec)#
        groups.num    <- length(groups.uniq)#
        tmp.dens      <- 0#
        ## loop over all groups at a height and compute the density#
        for (j in 1:groups.num) {#
            ## identify location of the group memebers#
            tmp.idx     <- which(clust.vec == groups.uniq[j])#
            tmp.memb    <- union(get.edgelist(myIgraph)[tmp.idx,1], get.edgelist(myIgraph)[tmp.idx,2])#
            ## compute the number of nodes and edges in the group#
            tmp.mc      <- length(tmp.idx)#
            tmp.nc      <- length(tmp.memb)#
            ## by convention, clusers with two nodes has a density of 0#
            if (tmp.nc > 2) {#
                tmp.dens    <- tmp.dens + 2*tmp.mc*(tmp.mc - (tmp.nc-1))/(e.num*(tmp.nc-2)*(tmp.nc-1))#
            }#
        }#
        dens.vec[i] <- tmp.dens#
    }#
    ## idenitfy the maximum density & corresponding height#
    pdens   <- data.frame(h=h.vec, den=dens.vec)#
    pdmax   <- max(dens.vec)#
    hmax    <- h.vec[dens.vec == pdmax]#
    ## isolate cluster memebers#
    clust.ids   <- cutree(myHclust, h=hmax)#
    clust.uniq  <- unique(clust.ids)#
    clust.num   <- length(clust.uniq)#
    clust.list  <- list()#
    clust.cnt   <- 1#
    for (i in 1:clust.num) {#
        tmp.clust   <- clust.uniq[i]#
        tmp.idx     <- which(as.vector(lm.dens$clust.ids) == tmp.clust)#
        tmp.memb    <- union(get.edgelist(myIgraph)[tmp.idx,1], get.edgelist(myIgraph)[tmp.idx,2])#
        if (length(tmp.memb) >= 3) {#
            clust.list[[clust.cnt]] <- tmp.memb#
            clust.cnt   <- clust.cnt + 1#
        }#
    }#
    return(list(pdens=pdens, pdmax=pdmax, hmax=hmax, clust.ids=clust.ids, clust.list=clust.list))#
}
a <- calcPartitionDensity(lm.clust, lm.igraph)
a
lm.lc$clusters
table(clust.ids)
length(    clust.uniq  <- unique(clust.ids)#
    clust.num   <- length(clust.uniq)#
    clust.list  <- list()#
)
clust.uniq  <- unique(clust.ids)#
    clust.num   <- length(clust.uniq)#
    clust.list  <- list()
clust.uniq
clust.num
i <- 49
tmp.clust   <- clust.uniq[i]#
        tmp.idx     <- which(as.vector(lm.dens$clust.ids) == tmp.clust)#
        tmp.memb    <- union(get.edgelist(myIgraph)[tmp.idx,1], get.edgelist(myIgraph)[tmp.idx,2])
myIgraph <- lm.igraph
tmp.clust   <- clust.uniq[i]#
        tmp.idx     <- which(as.vector(lm.dens$clust.ids) == tmp.clust)#
        tmp.memb    <- union(get.edgelist(myIgraph)[tmp.idx,1], get.edgelist(myIgraph)[tmp.idx,2])
tmp.clust
tmp.id
tmp.idx
as.vector(lm.dens$clust.ids)
clust.ids
tmp.idx
a <- 1:254
i
i <- 47
a[which(as.vector(lm.dens$clust.ids) == tmp.clust)]
a[which(as.vector(lm.dens$clust.ids) == 47)]
calcPartitionDensity    <- function(myHclust, myIgraph)#
{#
    h.vec       <- unique(myHclust$height)#
    h.num       <- length(h.vec)#
    e.num       <- nrow(get.edgelist(myIgraph))#
    e.idx       <- 1:e.num#
    ## matrix to hold the identify of group members at each height#
    clust.vec   <- vector(, length=h.num)#
    dens.vec    <- vector(, length=h.num)#
    ## loop each height and compute the partition density#
    for (i in 1:h.num) {#
        clust.vec     <- as.vector(cutree(myHclust, h=h.vec[i]))#
        groups.uniq   <- unique(clust.vec)#
        groups.num    <- length(groups.uniq)#
        tmp.dens      <- 0#
        ## loop over all groups at a height and compute the density#
        for (j in 1:groups.num) {#
            ## identify location of the group memebers#
            tmp.idx     <- which(clust.vec == groups.uniq[j])#
            tmp.memb    <- union(get.edgelist(myIgraph)[tmp.idx,1], get.edgelist(myIgraph)[tmp.idx,2])#
            ## compute the number of nodes and edges in the group#
            tmp.mc      <- length(tmp.idx)#
            tmp.nc      <- length(tmp.memb)#
            ## by convention, clusers with two nodes has a density of 0#
            if (tmp.nc > 2) {#
                tmp.dens    <- tmp.dens + 2*tmp.mc*(tmp.mc - (tmp.nc-1))/(e.num*(tmp.nc-2)*(tmp.nc-1))#
            }#
        }#
        dens.vec[i] <- tmp.dens#
    }#
    ## idenitfy the maximum density & corresponding height#
    pdens   <- data.frame(h=h.vec, den=dens.vec)#
    pdmax   <- max(dens.vec)#
    hmax    <- h.vec[dens.vec == pdmax]#
    ## isolate cluster memebers#
    clust.ids   <- cutree(myHclust, h=hmax)#
    clust.uniq  <- unique(clust.ids)#
    clust.num   <- length(clust.uniq)#
    clust.list  <- list()#
    clust.cnt   <- 1#
    for (i in 1:clust.num) {#
        tmp.clust   <- clust.uniq[i]#
        tmp.idx     <- e.idx[which(as.vector(lm.dens$clust.ids) == tmp.clust)]#
        tmp.memb    <- union(get.edgelist(myIgraph)[tmp.idx,1], get.edgelist(myIgraph)[tmp.idx,2])#
        if (length(tmp.memb) >= 3) {#
            clust.list[[clust.cnt]] <- tmp.memb#
            clust.cnt   <- clust.cnt + 1#
        }#
    }#
    return(list(pdens=pdens, pdmax=pdmax, hmax=hmax, clust.ids=clust.ids, clust.list=clust.list))#
}
a <- calcPartitionDensity(lm.clust, lm.igraph)
a
calcPartitionDensity    <- function(myHclust, myIgraph)#
{#
    h.vec       <- unique(myHclust$height)#
    h.num       <- length(h.vec)#
    e.num       <- nrow(get.edgelist(myIgraph))#
    e.idx       <- 1:e.num#
    ## matrix to hold the identify of group members at each height#
    clust.vec   <- vector(, length=h.num)#
    dens.vec    <- vector(, length=h.num)#
    ## loop each height and compute the partition density#
    for (i in 1:h.num) {#
        clust.vec     <- as.vector(cutree(myHclust, h=h.vec[i]))#
        groups.uniq   <- unique(clust.vec)#
        groups.num    <- length(groups.uniq)#
        tmp.dens      <- 0#
        ## loop over all groups at a height and compute the density#
        for (j in 1:groups.num) {#
            ## identify location of the group memebers#
            tmp.idx     <- which(clust.vec == groups.uniq[j])#
            tmp.memb    <- union(get.edgelist(myIgraph)[tmp.idx,1], get.edgelist(myIgraph)[tmp.idx,2])#
            ## compute the number of nodes and edges in the group#
            tmp.mc      <- length(tmp.idx)#
            tmp.nc      <- length(tmp.memb)#
            ## by convention, clusers with two nodes has a density of 0#
            if (tmp.nc > 2) {#
                tmp.dens    <- tmp.dens + 2*tmp.mc*(tmp.mc - (tmp.nc-1))/(e.num*(tmp.nc-2)*(tmp.nc-1))#
            }#
        }#
        dens.vec[i] <- tmp.dens#
    }#
    ## idenitfy the maximum density & corresponding height#
    pdens   <- data.frame(h=h.vec, den=dens.vec)#
    pdmax   <- max(dens.vec)#
    hmax    <- h.vec[dens.vec == pdmax]#
    ## isolate cluster memebers#
    clust.ids   <- cutree(myHclust, h=hmax)#
    clust.uniq  <- unique(clust.ids)#
    clust.num   <- length(clust.uniq)#
    clust.list  <- list()#
    clust.cnt   <- 1#
    for (i in 1:clust.num) {#
        tmp.clust   <- clust.uniq[i]#
        tmp.idx     <- e.idx[which(as.vector(myHclust$clust.ids) == tmp.clust)]#
        tmp.memb    <- union(get.edgelist(myIgraph)[tmp.idx,1], get.edgelist(myIgraph)[tmp.idx,2])#
        if (length(tmp.memb) >= 3) {#
            clust.list[[clust.cnt]] <- tmp.memb#
            clust.cnt   <- clust.cnt + 1#
        }#
    }#
    return(list(pdens=pdens, pdmax=pdmax, hmax=hmax, clust.ids=clust.ids, clust.list=clust.list))#
}
a <- calcPartitionDensity(lm.clust, lm.igraph)
a
calcPartitionDensity    <- function(myHclust, myIgraph)#
{#
    h.vec       <- unique(myHclust$height)#
    h.num       <- length(h.vec)#
    e.num       <- nrow(get.edgelist(myIgraph))#
    e.idx       <- 1:e.num#
    ## matrix to hold the identify of group members at each height#
    clust.vec   <- vector(, length=h.num)#
    dens.vec    <- vector(, length=h.num)#
    ## loop each height and compute the partition density#
    for (i in 1:h.num) {#
        clust.vec     <- as.vector(cutree(myHclust, h=h.vec[i]))#
        groups.uniq   <- unique(clust.vec)#
        groups.num    <- length(groups.uniq)#
        tmp.dens      <- 0#
        ## loop over all groups at a height and compute the density#
        for (j in 1:groups.num) {#
            ## identify location of the group memebers#
            tmp.idx     <- which(clust.vec == groups.uniq[j])#
            tmp.memb    <- union(get.edgelist(myIgraph)[tmp.idx,1], get.edgelist(myIgraph)[tmp.idx,2])#
            ## compute the number of nodes and edges in the group#
            tmp.mc      <- length(tmp.idx)#
            tmp.nc      <- length(tmp.memb)#
            ## by convention, clusers with two nodes has a density of 0#
            if (tmp.nc > 2) {#
                tmp.dens    <- tmp.dens + 2*tmp.mc*(tmp.mc - (tmp.nc-1))/(e.num*(tmp.nc-2)*(tmp.nc-1))#
            }#
        }#
        dens.vec[i] <- tmp.dens#
    }#
    ## idenitfy the maximum density & corresponding height#
    pdens   <- data.frame(h=h.vec, den=dens.vec)#
    pdmax   <- max(dens.vec)#
    hmax    <- h.vec[dens.vec == pdmax]#
    ## isolate cluster memebers#
    clust.ids   <- cutree(myHclust, h=hmax)#
    clust.uniq  <- unique(clust.ids)#
    clust.num   <- length(clust.uniq)#
    clust.list  <- list()#
    clust.cnt   <- 1#
    for (i in 1:clust.num) {#
        tmp.clust   <- clust.uniq[i]#
        tmp.idx     <- e.idx[which(as.vector(clust.ids) == tmp.clust)]#
        tmp.memb    <- union(get.edgelist(myIgraph)[tmp.idx,1], get.edgelist(myIgraph)[tmp.idx,2])#
        if (length(tmp.memb) >= 3) {#
            clust.list[[clust.cnt]] <- tmp.memb#
            clust.cnt   <- clust.cnt + 1#
        }#
    }#
    return(list(pdens=pdens, pdmax=pdmax, hmax=hmax, clust.ids=clust.ids, clust.list=clust.list))#
}
a <- calcPartitionDensity(lm.clust, lm.igraph)
a
calcPartitionDensity    <- function(myHclust, myIgraph)#
{#
    h.vec       <- unique(myHclust$height)#
    h.num       <- length(h.vec)#
    e.num       <- nrow(get.edgelist(myIgraph))#
    e.idx       <- 1:e.num#
    ## matrix to hold the identify of group members at each height#
    clust.vec   <- vector(, length=h.num)#
    dens.vec    <- vector(, length=h.num)#
    ## loop each height and compute the partition density#
    for (i in 1:h.num) {#
        clust.vec     <- as.vector(cutree(myHclust, h=h.vec[i]))#
        groups.uniq   <- unique(clust.vec)#
        groups.num    <- length(groups.uniq)#
        tmp.dens      <- 0#
        ## loop over all groups at a height and compute the density#
        for (j in 1:groups.num) {#
            ## identify location of the group memebers#
            tmp.idx     <- which(clust.vec == groups.uniq[j])#
            tmp.memb    <- union(get.edgelist(myIgraph)[tmp.idx,1], get.edgelist(myIgraph)[tmp.idx,2])#
            ## compute the number of nodes and edges in the group#
            tmp.mc      <- length(tmp.idx)#
            tmp.nc      <- length(tmp.memb)#
            ## by convention, clusers with two nodes has a density of 0#
            if (tmp.nc > 2) {#
                tmp.dens    <- tmp.dens + 2*tmp.mc*(tmp.mc - (tmp.nc-1))/(e.num*(tmp.nc-2)*(tmp.nc-1))#
            }#
        }#
        dens.vec[i] <- tmp.dens#
    }#
    ## idenitfy the maximum density & corresponding height#
    pdens   <- data.frame(h=h.vec, den=dens.vec)#
    pdmax   <- max(dens.vec)#
    hmax    <- h.vec[dens.vec == pdmax]#
    ## isolate cluster memebers#
    clust.ids   <- cutree(myHclust, h=hmax)#
    clust.uniq  <- unique(clust.ids)#
    clust.num   <- length(clust.uniq)#
    clust.list  <- list()#
    clust.cnt   <- 1#
    for (i in 1:clust.num) {#
        tmp.clust   <- clust.uniq[i]#
        tmp.idx     <- e.idx[which(clust.ids == tmp.clust)]#
        tmp.memb    <- union(get.edgelist(myIgraph)[tmp.idx,1], get.edgelist(myIgraph)[tmp.idx,2])#
        if (length(tmp.memb) >= 3) {#
            clust.list[[clust.cnt]] <- tmp.memb#
            clust.cnt   <- clust.cnt + 1#
        }#
    }#
    return(list(pdens=pdens, pdmax=pdmax, hmax=hmax, clust.ids=clust.ids, clust.list=clust.list))#
}
a <- calcPartitionDensity(lm.clust, lm.igraph)
a
myHclust <- lm.dens
myHclust <- lm.clust
myIgraph <- lm.igraph
h.vec       <- unique(myHclust$height)#
    h.num       <- length(h.vec)#
    e.num       <- nrow(get.edgelist(myIgraph))#
    e.idx       <- 1:e.num#
    ## matrix to hold the identify of group members at each height#
    clust.vec   <- vector(, length=h.num)#
    dens.vec    <- vector(, length=h.num)#
    ## loop each height and compute the partition density#
    for (i in 1:h.num) {#
        clust.vec     <- as.vector(cutree(myHclust, h=h.vec[i]))#
        groups.uniq   <- unique(clust.vec)#
        groups.num    <- length(groups.uniq)#
        tmp.dens      <- 0#
        ## loop over all groups at a height and compute the density#
        for (j in 1:groups.num) {#
            ## identify location of the group memebers#
            tmp.idx     <- which(clust.vec == groups.uniq[j])#
            tmp.memb    <- union(get.edgelist(myIgraph)[tmp.idx,1], get.edgelist(myIgraph)[tmp.idx,2])#
            ## compute the number of nodes and edges in the group#
            tmp.mc      <- length(tmp.idx)#
            tmp.nc      <- length(tmp.memb)#
            ## by convention, clusers with two nodes has a density of 0#
            if (tmp.nc > 2) {#
                tmp.dens    <- tmp.dens + 2*tmp.mc*(tmp.mc - (tmp.nc-1))/(e.num*(tmp.nc-2)*(tmp.nc-1))#
            }#
        }#
        dens.vec[i] <- tmp.dens#
    }#
    ## idenitfy the maximum density & corresponding height#
    pdens   <- data.frame(h=h.vec, den=dens.vec)#
    pdmax   <- max(dens.vec)#
    hmax    <- h.vec[dens.vec == pdmax]#
    ## isolate cluster memebers#
    clust.ids   <- cutree(myHclust, h=hmax)#
    clust.uniq  <- unique(clust.ids)#
    clust.num   <- length(clust.uniq)#
    clust.list  <- list()
clust.ids
table(clust.ids)
names(table(clust.ids))
as.integer(names(table(clust.ids)))
as.vector(clust.ids)
unique(clust.ids)
clust.num
tmp.clust   <- clust.uniq[i]
tmp.clust
i
i <- 1
tmp.clust   <- clust.uniq[i]
tmp.clust
i <- 2
tmp.clust   <- clust.uniq[i]
tmp.clust
which(clust.ids == tmp.clust)
e.idx
e.idx[which(clust.ids == tmp.clust)]
tmp.memb    <- union(get.edgelist(myIgraph)[tmp.idx,1], get.edgelist(myIgraph)[tmp.idx,2])
tmp.memb
get.edgelist(myIgraph)
tmp.idx     <- e.idx[which(clust.ids == tmp.clust)]#
        tmp.memb    <- union(get.edgelist(myIgraph)[tmp.idx,1], get.edgelist(myIgraph)[tmp.idx,2])
tmp.idx
tmp.memb
i <- 47
tmp.clust   <- clust.uniq[i]#
        tmp.idx     <- e.idx[which(clust.ids == tmp.clust)]#
        tmp.memb    <- union(get.edgelist(myIgraph)[tmp.idx,1], get.edgelist(myIgraph)[tmp.idx,2])
tmp.clust
tmp.idx
tmp.memb
get.edgelist(myIgraph)[tmp.idx,1]
get.edgelist(myIgraph)[tmp.idx,2]
length(tmp.idx)
lm.lc$clusters
tmp.idx
## isolate cluster memebers#
    clust.ids   <- cutree(myHclust, h=hmax)#
    clust.uniq  <- unique(clust.ids)#
    clust.num   <- length(clust.uniq)#
    clust.list  <- list()#
    clust.cnt   <- 1#
    for (i in 1:clust.num) {#
        tmp.clust   <- clust.uniq[i]#
        tmp.idx     <- e.idx[which(clust.ids == tmp.clust)]#
        if (length(tmp.idx) <= 3) {#
            tmp.memb    <- union(get.edgelist(myIgraph)[tmp.idx,1], get.edgelist(myIgraph)[tmp.idx,2])#
            if (tmp.memb > 2) {#
                clust.list[[clust.cnt]] <- tmp.idx#
                clust.cnt   <- clust.cnt + 1#
            }#
        } else {#
            clust.list[[clust.cnt]] <- tmp.idx#
            clust.cnt   <- clust.cnt + 1#
        }#
    }
warning()
warnings()
## isolate cluster memebers#
    clust.ids   <- cutree(myHclust, h=hmax)#
    clust.uniq  <- unique(clust.ids)#
    clust.num   <- length(clust.uniq)#
    clust.list  <- list()#
    clust.cnt   <- 1
i <- 57
i <- 47
tmp.clust   <- clust.uniq[i]#
        tmp.idx     <- e.idx[which(clust.ids == tmp.clust)]
tmp.idx
if (length(tmp.idx) <= 3) {#
            tmp.memb    <- union(get.edgelist(myIgraph)[tmp.idx,1], get.edgelist(myIgraph)[tmp.idx,2])#
            if (tmp.memb > 2) {#
                clust.list[[clust.cnt]] <- tmp.idx#
                clust.cnt   <- clust.cnt + 1#
            }#
        } else {#
            clust.list[[clust.cnt]] <- tmp.idx#
            clust.cnt   <- clust.cnt + 1#
        }
clust.list[[clust.cnt]]
clust.list[[1]]
clust.cnt   <- 1#
    for (i in 1:clust.num) {#
        tmp.clust   <- clust.uniq[i]#
        tmp.idx     <- e.idx[which(clust.ids == tmp.clust)]#
        if (length(tmp.idx) <= 3) {#
            tmp.memb    <- union(get.edgelist(myIgraph)[tmp.idx,1], get.edgelist(myIgraph)[tmp.idx,2])#
            if (tmp.memb > 2) {#
                clust.list[[clust.cnt]] <- tmp.idx#
                clust.cnt   <- clust.cnt + 1#
            }#
        } else {#
            clust.list[[clust.cnt]] <- tmp.idx#
            clust.cnt   <- clust.cnt + 1#
        }#
    }
i <- 1
tmp.clust   <- clust.uniq[i]#
        tmp.idx     <- e.idx[which(clust.ids == tmp.clust)]
tmp.clust
tmp.idx
clust.cnt   <- 1#
    for (i in 1:clust.num) {#
        tmp.clust   <- clust.uniq[i]#
        tmp.idx     <- e.idx[which(clust.ids == tmp.clust)]#
        if (length(tmp.idx) > 1) {#
            if (length(tmp.idx) %in% c(2,3)) {#
                tmp.memb    <- union(get.edgelist(myIgraph)[tmp.idx,1], get.edgelist(myIgraph)[tmp.idx,2])#
                clust.list[[clust.cnt]] <- tmp.idx#
                clust.cnt   <- clust.cnt + 1#
            } else {#
                clust.list[[clust.cnt]] <- tmp.idx#
                clust.cnt   <- clust.cnt + 1#
            }#
        }#
    }
clust.list
clust.cnt   <- 1#
    for (i in 1:clust.num) {#
        tmp.clust   <- clust.uniq[i]#
        tmp.idx     <- e.idx[which(clust.ids == tmp.clust)]#
        tmp.memb    <- union(get.edgelist(myIgraph)[tmp.idx,1], get.edgelist(myIgraph)[tmp.idx,2])#
        if (length(tmp.memb) >= 3) {#
            clust.list[[clust.cnt]] <- tmp.idx#
            clust.cnt   <- clust.cnt + 1#
        }#
    }
clust.list
tmp.memb
length(tmp.memb)
## isolate cluster memebers#
    clust.ids   <- cutree(myHclust, h=hmax)#
    clust.uniq  <- unique(clust.ids)#
    clust.num   <- length(clust.uniq)#
    clust.list  <- list()#
    clust.cnt   <- 1#
    for (i in 1:clust.num) {#
        tmp.clust   <- clust.uniq[i]#
        tmp.idx     <- e.idx[which(clust.ids == tmp.clust)]#
        tmp.memb    <- union(get.edgelist(myIgraph)[tmp.idx,1], get.edgelist(myIgraph)[tmp.idx,2])#
        if (length(tmp.memb) >= 3) {#
            clust.list[[clust.cnt]] <- tmp.idx#
            clust.cnt   <- clust.cnt + 1#
        }#
    }
clust.list
## isolate cluster memebers#
    clust.ids   <- cutree(myHclust, h=hmax)#
    clust.uniq  <- unique(clust.ids)#
    clust.num   <- length(clust.uniq)#
    clust.list  <- list()#
    clust.cnt   <- 1#
    for (i in 1:clust.num) {#
        tmp.clust   <- clust.uniq[i]#
        tmp.idx     <- e.idx[which(clust.ids == tmp.clust)]#
        tmp.memb    <- union(get.edgelist(myIgraph)[tmp.idx,1], get.edgelist(myIgraph)[tmp.idx,2])#
        if ( length(tmp.idx) >= 3 ) {#
            clust.list[[clust.cnt]] <- tmp.idx#
            clust.cnt   <- clust.cnt + 1#
        }#
    }
clust.list
lm.lc$clusters
lapply(lm.lc$clusters, length)
as.vector(lapply(lm.lc$clusters, length))
unlist(lapply(lm.lc$clusters, length))
##------------------------------------------------------------------#
## The purpose of this script is to re-create an example set of#
## clusters.  The example (the Les Miserables characters) set of#
## edges is taken from Ahn, and there is an R package that will#
## reproduce that results (linkcomm()).  I want to reproduce it#
## as well because I will be modifying the basic result (i.e.,#
## a similarity matrix to reproduce the Ye [?] et al. paper.#
##------------------------------------------------------------------#
#
##------------------------------------------------------------------#
## Load libraries#
##------------------------------------------------------------------#
library(igraph)                 ## contains graph functions#
library(linkcomm)               ## contains link community functions#
library(dendextend)             ## contains dendrogram functions#
library(caTools)#
librart(gdata)#
#
##------------------------------------------------------------------#
## Clear the workspace#
##------------------------------------------------------------------#
rm(list=ls())#
#
##------------------------------------------------------------------#
## Load utility functions#
##------------------------------------------------------------------#
source("/Users/alexstephens/Development/kaggle/social_circle/k_soc/00_Utilities.r")#
##------------------------------------------------------------------#
## Benchmark: Les Miserables characters connected graph#
##------------------------------------------------------------------#
#
## load the raw dataset (from linkcomm())#
lm <- lesmiserables#
#
##------------------------------------------------------------------#
## Step 1:  This is somewhat redundant, but translate the Les Mis#
## factor/edge list into the egonet structure that I've loaded#
## from the kaggle competition.#
##------------------------------------------------------------------#
#
## convert the data of factors into characters#
tmp.lm <- convert.magic(lm, c("V1","V2"), c("character","character"))#
#
## map character names to integers#
nodes_l.uniq    <- unique(tmp.lm$V1)#
nodes_r.uniq    <- unique(tmp.lm$V2)#
characters.uniq <- union(nodes_l.uniq, nodes_r.uniq)#
characters.ids  <- 1:length(characters.uniq)#
#
## define the egonet#
lm.egonet  <- list()#
#
## load the egonet#
for (i in 1:length(nodes_l.uniq)) {#
    ## get a vertex & assign an id#
    tmp.node    <- nodes_l.uniq[i]#
    tmp.id      <- characters.ids[ which(characters.uniq == tmp.node)]#
    char.id     <- paste("ID_",tmp.id,sep="")#
    ## get the list of characters (and their ids) associated with this vertex#
    lm.egonet[[char.id]] <- paste("ID_", characters.ids[ which(characters.uniq %in% tmp.lm$V2[which(tmp.lm$V1 == tmp.node)]) ], sep="")#
}#
#
##------------------------------------------------------------------#
## Step 2:  At this point, the Les Mis data are in a format that#
## is similar to the loaded kaggle data format. Load the raw data#
## into an igraph object#
##------------------------------------------------------------------#
lm.igraph   <- convEgonetListToIgraphObject(lm.egonet)#
##------------------------------------------------------------------#
## Step 3:  Compute the dissimilarity measure amongst the clusters.#
## The similarity measure is the Jaccard coefficient. The Jaccard#
## *distance* is 1 minus the Jaccard coefficient.#
##------------------------------------------------------------------#
#
lm.sim      <- calcSimilarityMatrix(lm.igraph)  ## similarity matrix#
lm.dis      <- 1 - lm.sim                       ## jaccard distance#
#
##------------------------------------------------------------------#
## Step 3:  Compute the cluster#
##------------------------------------------------------------------#
#
## create a distance object from the dissimilarity matrix#
lm.dist     <- as.dist(lm.dis)#
#
## compute a cluster#
lm.clust    <- hclust(lm.dist, method="single")#
lm.dend     <- as.dendrogram(lm.clust)#
##------------------------------------------------------------------#
## Step 4:  Verify cluster output using linkcomm() [ok]#
##------------------------------------------------------------------#
## use linkcomm() to compute the cluster#
lm.lc       <- getLinkCommunities(get.data.frame(lm.igraph,"edges"), hcmethod="single")#
comp.clust  <- cbind(lm.lc$hclust$height, lm.clust$height, lm.lc$hclust$height-lm.clust$height)#
##------------------------------------------------------------------#
## Step 5:  Calculate the partition density#
##------------------------------------------------------------------#
#
lm.dens <- calcPartitionDensity(lm.clust, lm.igraph)
lm.dens
q()
##------------------------------------------------------------------#
## Clear the workspace#
##------------------------------------------------------------------#
rm(list=ls())#
#
##------------------------------------------------------------------#
## Set the working directory#
##------------------------------------------------------------------#
setwd("/Users/alexstephens/Development/poker/omaha_hi/data")#
#
##------------------------------------------------------------------#
## The PPT hands Omaha hands have the follow structures#
##------------------------------------------------------------------#
## XYZW#
## (XY)ZW#
## X(YZ)W#
## XY(ZW)#
## (XYZ)W#
## X(YZW)#
## (XYZW)#
## (XY)(ZW)#
##------------------------------------------------------------------#
#
##------------------------------------------------------------------#
## The goal is to convert these into the PPT generic syntax format#
##------------------------------------------------------------------#
## E.g., translate (AJ)(AJ) --> AxJxAyJy (double-suited double-pair)#
##------------------------------------------------------------------#
##------------------------------------------------------------------#
## <function> appendSuits#
##------------------------------------------------------------------#
## Takes a hand character vector, e.g., c("A","J","A","J") and#
## appends a suit character vector, e.g., c("x", "x", "y", "y")#
##------------------------------------------------------------------#
appendSuits <- function(h, s) {#
    return(paste(paste(h,s,sep=""), collapse=""))#
}#
#
##------------------------------------------------------------------#
## <function> processHandFile#
##------------------------------------------------------------------#
## Takes a PPT Omaha hand file as an input and writes the translated#
## format to a file.  The output filename contains the "_genericSyntax"#
## postfix.#
##------------------------------------------------------------------#
processHandFile <- function(in.file) {#
#
    ## process the filename#
    tmp.file    <- unlist(strsplit(in.file, "[.]"))#
    out.file    <- paste0(tmp.file[1], "_genericSyntax", ".", tmp.file[2])#
#
    ## read the input file and create an identically-sized output matrix#
    hf          <- read.csv(in.file, header=FALSE)#
    ho          <- matrix(,nrow=nrow(hf), ncol=1)#
#
    ## loop over each row in the file and process the ranked hand#
    for (i in 1:nrow(hf)) {#
        ## process a hand#
        tmp.ch      <- unlist(strsplit(as.character(hf[i,]), ""))   ## split hand into individual characters#
        tmp.nch     <- length(tmp.ch)                               ## count number of characters#
        tmp.lp      <- which(tmp.ch %in% c("("))                    ## location of left parentheses#
        tmp.rp      <- which(tmp.ch %in% c(")"))                    ## location of right parentheses#
        tmp.ranks   <- tmp.ch[which(!(tmp.ch %in% c("(",")")))]     ## extract ranks#
        ## the if/then processes the hand based on the length, and#
        ## for single-suited suited hands it will use the location#
        ## of the right and left parentheses to assign the suits#
        ## double suited#
        if (tmp.nch == 8) {#
            tmp.suits   <- c("x","x","y","y")#
        ## single suited#
        } else if (tmp.nch == 6) {#
            ## (XY)ZW [1,4]#
            if ((tmp.lp == 1) & (tmp.rp == 4)) {#
                tmp.suits <- c("x","x","y","z")#
            ## X(YZ)W [2,5]#
            } else if ((tmp.lp == 2) & (tmp.rp == 5)) {#
                tmp.suits <- c("x","y","y","z")#
            ## XY(ZW) [3,6]#
            } else if ((tmp.lp == 3) & (tmp.rp == 6)) {#
                tmp.suits <- c("x","y","z","z")#
            ## (XYZ)W [1,5]#
            } else if ((tmp.lp == 1) & (tmp.rp == 5)) {#
                tmp.suits <- c("x","x","x","y")#
            ## X(YZW) [2,6]#
            } else if ((tmp.lp == 2) & (tmp.rp == 6)) {#
                tmp.suits <- c("x","y","y","y")#
            ## (XYZW) [1,6]#
            } else if ((tmp.lp == 1) & (tmp.rp == 6)) {#
                tmp.suits <- c("x","x","x","x")#
            }#
        ## rainbow#
        } else if (tmp.nch == 4) {#
            tmp.suits   <- c("x","y","z","w")#
        ## error#
        } else {#
            stop("unexpected string lenght\n")#
        }#
    ## insert the hand translated into generic syntax to a matrix#
    ho[i,1]  <- appendSuits(tmp.ranks, tmp.suits)#
    }#
#
    ## save the output as a file#
    write.table(ho, file=out.file, row.names=FALSE, col.names=FALSE)#
}
##------------------------------------------------------------------#
## <main> process hands#
##------------------------------------------------------------------#
processHandFile("ppt_plo_handrankings_03handed.txt")#
processHandFile("ppt_plo_handrankings_06handed.txt")#
processHandFile("ppt_plo_handrankings_10handed.txt")#
processHandFile("ppt_plo_handrankings_preflop_vs_random.txt")
q()
