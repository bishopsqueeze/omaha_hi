install.packages("ctv")
library(ctv)
install.views("Bayesian")#
#ChemPhys 	Chemometrics and Computational Physics#
#ClinicalTrials 	Clinical Trial Design, Monitoring, and Analysis#
install.views("Cluster")                    ## Cluster Analysis & Finite Mixture Models#
install.views("DifferentialEquations")      ## Differential Equations#
install.views("Distributions")              ## Probability Distributions#
install.views("Econometrics")               ## Computational Econometrics#
##Environmetrics 	Analysis of Ecological and Environmental Data#
##ExperimentalDesign 	Design of Experiments (DoE) & Analysis of Experimental Data#
install.views("Finance")                    ## Empirical Finance#
##Genetics 	Statistical Genetics#
install.views("Graphics")                   ## Graphic Displays & Dynamic Graphics & Graphic Devices & Visualization#
install.views("HighPerformanceComputing") 	## High-Performance and Parallel Computing with R#
install.views("MachineLearning")            ## Machine Learning & Statistical Learning#
install.views("MedicalImaging")             ## Medical Image Analysis#
##MetaAnalysis 	Meta-Analysis#
install.views("Multivariate")               ## Multivariate Statistics#
install.views("NaturalLanguageProcessing") 	## Natural Language Processing#
install.views("NumericalMathematics")       ## Numerical Mathematics#
##OfficialStatistics 	Official Statistics & Survey Methodology#
install.views("Optimization")               ## Optimization and Mathematical Programming#
##Pharmacokinetics 	Analysis of Pharmacokinetic Data#
##Phylogenetics 	Phylogenetics, Especially Comparative Methods#
install.views("Psychometrics")              ## Psychometric Models and Methods#
##ReproducibleResearch 	Reproducible Research#
install.views("Robust")                     ## Robust Statistical Methods#
##SocialSciences 	Statistics for the Social Sciences#
install.views("Spatial")                    ## Analysis of Spatial Data#
install.views("SpatioTemporal")             ## Handling and Analyzing Spatio-Temporal Data#
install.views("Survival")                   ## Survival Analysis#
install.views("TimeSeries")                 ## Time Series Analysis#
##WebTechnologies 	Web Technologies and Services#
##gR 	gRaphical Models in R
q()
combin
library(combin)
q()
##------------------------------------------------------------------#
## Clear the workspace#
##------------------------------------------------------------------#
rm(list=ls())#
#
##------------------------------------------------------------------#
## Set the working directory#
##------------------------------------------------------------------#
setwd("/Users/alexstephens/Development/poker/omaha_hi/data")#
#
##------------------------------------------------------------------#
## The PPT hands Omaha hands have the follow structures#
##------------------------------------------------------------------#
## XYZW#
## (XY)ZW#
## X(YZ)W#
## XY(ZW)#
## (XYZ)W#
## X(YZW)#
## (XYZW)#
## (XY)(ZW)#
##------------------------------------------------------------------#
#
##------------------------------------------------------------------#
## The goal is to convert these into the PPT generic syntax format#
##------------------------------------------------------------------#
## E.g., translate (AJ)(AJ) --> AxJxAyJy (double-suited double-pair)#
##------------------------------------------------------------------#
##------------------------------------------------------------------#
## <function> appendSuits#
##------------------------------------------------------------------#
## Takes a hand character vector, e.g., c("A","J","A","J") and#
## appends a suit character vector, e.g., c("x", "x", "y", "y")#
##------------------------------------------------------------------#
appendSuits <- function(h, s) {#
    return(paste(paste(h,s,sep=""), collapse=""))#
}
##------------------------------------------------------------------#
## <function> processHandFile#
##------------------------------------------------------------------#
## Takes a PPT Omaha hand file as an input and writes the translated#
## format to a file.  The output filename contains the "_genericSyntax"#
## postfix.#
##------------------------------------------------------------------#
processHandFile <- function(in.file) {#
#
    ## process the filename#
    tmp.file    <- unlist(strsplit(in.file, "[.]"))#
    out.file    <- paste0(tmp.file[1], "_genericSyntax", ".", tmp.file[2])#
#
    ## read the input file and create an identically-sized output matrix#
    hf          <- read.csv(in.file, header=FALSE)#
    ho          <- matrix(,nrow=nrow(hf), ncol=1)#
#
    ## loop over each row in the file and process the ranked hand#
    for (i in 1:nrow(hf)) {#
        ## process a hand#
        tmp.ch      <- unlist(strsplit(as.character(hf[i,]), ""))   ## split hand into individual characters#
        tmp.nch     <- length(tmp.ch)                               ## count number of characters#
        tmp.lp      <- which(tmp.ch %in% c("("))                    ## location of left parentheses#
        tmp.rp      <- which(tmp.ch %in% c(")"))                    ## location of right parentheses#
        tmp.ranks   <- tmp.ch[which(!(tmp.ch %in% c("(",")")))]     ## extract ranks#
        ## the if/then processes the hand based on the length, and#
        ## for single-suited suited hands it will use the location#
        ## of the right and left parentheses to assign the suits#
        ## double suited#
        if (tmp.nch == 8) {#
            tmp.suits   <- c("x","x","y","y")#
        ## single suited#
        } else if (tmp.nch == 6) {#
            ## (XY)ZW [1,4]#
            if ((tmp.lp == 1) & (tmp.rp == 4)) {#
                tmp.suits <- c("x","x","y","z")#
            ## X(YZ)W [2,5]#
            } else if ((tmp.lp == 2) & (tmp.rp == 5)) {#
                tmp.suits <- c("x","y","y","z")#
            ## XY(ZW) [3,6]#
            } else if ((tmp.lp == 3) & (tmp.rp == 6)) {#
                tmp.suits <- c("x","y","z","z")#
            ## (XYZ)W [1,5]#
            } else if ((tmp.lp == 1) & (tmp.rp == 5)) {#
                tmp.suits <- c("x","x","x","y")#
            ## X(YZW) [2,6]#
            } else if ((tmp.lp == 2) & (tmp.rp == 6)) {#
                tmp.suits <- c("x","y","y","y")#
            ## (XYZW) [1,6]#
            } else if ((tmp.lp == 1) & (tmp.rp == 6)) {#
                tmp.suits <- c("x","x","x","x")#
            }#
        ## rainbow#
        } else if (tmp.nch == 4) {#
            tmp.suits   <- c("x","y","z","w")#
        ## error#
        } else {#
            stop("unexpected string lenght\n")#
        }#
    ## insert the hand translated into generic syntax to a matrix#
    ho[i,1]  <- appendSuits(tmp.ranks, tmp.suits)#
    }#
#
    ## save the output as a file#
    #write.table(ho, file=out.file, row.names=FALSE, col.names=FALSE)#
}
processHandFile("ppt_plo_handrankings_03handed.txt")
##------------------------------------------------------------------#
## Clear the workspace#
##------------------------------------------------------------------#
rm(list=ls())#
#
##------------------------------------------------------------------#
## Set the working directory#
##------------------------------------------------------------------#
setwd("/Users/alexstephens/Development/poker/omaha_hi/data/pptoo/OmahaHi")
processHandFile("ppt_plo_handrankings_03handed.txt")
##------------------------------------------------------------------#
## Clear the workspace#
##------------------------------------------------------------------#
rm(list=ls())#
#
##------------------------------------------------------------------#
## Set the working directory#
##------------------------------------------------------------------#
setwd("/Users/alexstephens/Development/poker/omaha_hi/data/pptoo/OmahaHi")#
#
##------------------------------------------------------------------#
## The PPT hands Omaha hands have the follow structures#
##------------------------------------------------------------------#
## XYZW#
## (XY)ZW#
## X(YZ)W#
## XY(ZW)#
## (XYZ)W#
## X(YZW)#
## (XYZW)#
## (XY)(ZW)#
##------------------------------------------------------------------#
#
##------------------------------------------------------------------#
## The goal is to convert these into the PPT generic syntax format#
##------------------------------------------------------------------#
## E.g., translate (AJ)(AJ) --> AxJxAyJy (double-suited double-pair)#
##------------------------------------------------------------------#
##------------------------------------------------------------------#
## <function> appendSuits#
##------------------------------------------------------------------#
## Takes a hand character vector, e.g., c("A","J","A","J") and#
## appends a suit character vector, e.g., c("x", "x", "y", "y")#
##------------------------------------------------------------------#
appendSuits <- function(h, s) {#
    return(paste(paste(h,s,sep=""), collapse=""))#
}#
#
##------------------------------------------------------------------#
## <function> processHandFile#
##------------------------------------------------------------------#
## Takes a PPT Omaha hand file as an input and writes the translated#
## format to a file.  The output filename contains the "_genericSyntax"#
## postfix.#
##------------------------------------------------------------------#
processHandFile <- function(in.file) {#
#
    ## process the filename#
    tmp.file    <- unlist(strsplit(in.file, "[.]"))#
    out.file    <- paste0(tmp.file[1], "_genericSyntax", ".", tmp.file[2])#
#
    ## read the input file and create an identically-sized output matrix#
    hf          <- read.csv(in.file, header=FALSE)#
    ho          <- matrix(,nrow=nrow(hf), ncol=1)#
#
    ## loop over each row in the file and process the ranked hand#
    for (i in 1:nrow(hf)) {#
        ## process a hand#
        tmp.ch      <- unlist(strsplit(as.character(hf[i,]), ""))   ## split hand into individual characters#
        tmp.nch     <- length(tmp.ch)                               ## count number of characters#
        tmp.lp      <- which(tmp.ch %in% c("("))                    ## location of left parentheses#
        tmp.rp      <- which(tmp.ch %in% c(")"))                    ## location of right parentheses#
        tmp.ranks   <- tmp.ch[which(!(tmp.ch %in% c("(",")")))]     ## extract ranks#
        ## the if/then processes the hand based on the length, and#
        ## for single-suited suited hands it will use the location#
        ## of the right and left parentheses to assign the suits#
        ## double suited#
        if (tmp.nch == 8) {#
            tmp.suits   <- c("x","x","y","y")#
        ## single suited#
        } else if (tmp.nch == 6) {#
            ## (XY)ZW [1,4]#
            if ((tmp.lp == 1) & (tmp.rp == 4)) {#
                tmp.suits <- c("x","x","y","z")#
            ## X(YZ)W [2,5]#
            } else if ((tmp.lp == 2) & (tmp.rp == 5)) {#
                tmp.suits <- c("x","y","y","z")#
            ## XY(ZW) [3,6]#
            } else if ((tmp.lp == 3) & (tmp.rp == 6)) {#
                tmp.suits <- c("x","y","z","z")#
            ## (XYZ)W [1,5]#
            } else if ((tmp.lp == 1) & (tmp.rp == 5)) {#
                tmp.suits <- c("x","x","x","y")#
            ## X(YZW) [2,6]#
            } else if ((tmp.lp == 2) & (tmp.rp == 6)) {#
                tmp.suits <- c("x","y","y","y")#
            ## (XYZW) [1,6]#
            } else if ((tmp.lp == 1) & (tmp.rp == 6)) {#
                tmp.suits <- c("x","x","x","x")#
            }#
        ## rainbow#
        } else if (tmp.nch == 4) {#
            tmp.suits   <- c("x","y","z","w")#
        ## error#
        } else {#
            stop("unexpected string lenght\n")#
        }#
    ## insert the hand translated into generic syntax to a matrix#
    ho[i,1]  <- appendSuits(tmp.ranks, tmp.suits)#
    }#
#
    ## save the output as a file#
    #write.table(ho, file=out.file, row.names=FALSE, col.names=FALSE)#
}#
##------------------------------------------------------------------#
## <main> process hands#
##------------------------------------------------------------------
processHandFile("ppt_plo_handrankings_03handed.txt")
ls()
##------------------------------------------------------------------#
## <function> processHandFile#
##------------------------------------------------------------------#
## Takes a PPT Omaha hand file as an input and writes the translated#
## format to a file.  The output filename contains the "_genericSyntax"#
## postfix.#
##------------------------------------------------------------------#
processHandFile <- function(in.file) {#
#
    ## process the filename#
    tmp.file    <- unlist(strsplit(in.file, "[.]"))#
    out.file    <- paste0(tmp.file[1], "_genericSyntax", ".", tmp.file[2])#
#
    ## read the input file and create an identically-sized output matrix#
    hf          <- read.csv(in.file, header=FALSE)#
    ho          <- matrix(,nrow=nrow(hf), ncol=1)#
#
    ## loop over each row in the file and process the ranked hand#
    for (i in 1:nrow(hf)) {#
        ## process a hand#
        tmp.ch      <- unlist(strsplit(as.character(hf[i,]), ""))   ## split hand into individual characters#
        tmp.nch     <- length(tmp.ch)                               ## count number of characters#
        tmp.lp      <- which(tmp.ch %in% c("("))                    ## location of left parentheses#
        tmp.rp      <- which(tmp.ch %in% c(")"))                    ## location of right parentheses#
        tmp.ranks   <- tmp.ch[which(!(tmp.ch %in% c("(",")")))]     ## extract ranks#
        ## the if/then processes the hand based on the length, and#
        ## for single-suited suited hands it will use the location#
        ## of the right and left parentheses to assign the suits#
        ## double suited#
        if (tmp.nch == 8) {#
            tmp.suits   <- c("x","x","y","y")#
        ## single suited#
        } else if (tmp.nch == 6) {#
            ## (XY)ZW [1,4]#
            if ((tmp.lp == 1) & (tmp.rp == 4)) {#
                tmp.suits <- c("x","x","y","z")#
            ## X(YZ)W [2,5]#
            } else if ((tmp.lp == 2) & (tmp.rp == 5)) {#
                tmp.suits <- c("x","y","y","z")#
            ## XY(ZW) [3,6]#
            } else if ((tmp.lp == 3) & (tmp.rp == 6)) {#
                tmp.suits <- c("x","y","z","z")#
            ## (XYZ)W [1,5]#
            } else if ((tmp.lp == 1) & (tmp.rp == 5)) {#
                tmp.suits <- c("x","x","x","y")#
            ## X(YZW) [2,6]#
            } else if ((tmp.lp == 2) & (tmp.rp == 6)) {#
                tmp.suits <- c("x","y","y","y")#
            ## (XYZW) [1,6]#
            } else if ((tmp.lp == 1) & (tmp.rp == 6)) {#
                tmp.suits <- c("x","x","x","x")#
            }#
        ## rainbow#
        } else if (tmp.nch == 4) {#
            tmp.suits   <- c("x","y","z","w")#
        ## error#
        } else {#
            stop("unexpected string lenght\n")#
        }#
    ## insert the hand translated into generic syntax to a matrix#
    ho[i,1]  <- appendSuits(tmp.ranks, tmp.suits)#
    }#
#
    ## save the output as a file#
    #write.table(ho, file=out.file, row.names=FALSE, col.names=FALSE)#
    return(list(hf=hf, ho=ho))#
}
a <- processHandFile("ppt_plo_handrankings_03handed.txt")
a
summary(a)
head(a[["hf"]])
head(a[["ho"]])
in.file <- "ppt_plo_handrankings_03handed.txt"
## process the filename#
    tmp.file    <- unlist(strsplit(in.file, "[.]"))#
    out.file    <- paste0(tmp.file[1], "_genericSyntax", ".", tmp.file[2])#
#
    ## read the input file and create an identically-sized output matrix#
    hf          <- read.csv(in.file, header=FALSE)#
    ho          <- matrix(,nrow=nrow(hf), ncol=1)
i <- 1
## process a hand#
        tmp.ch      <- unlist(strsplit(as.character(hf[i,]), ""))   ## split hand into individual characters#
        tmp.nch     <- length(tmp.ch)                               ## count number of characters#
        tmp.lp      <- which(tmp.ch %in% c("("))                    ## location of left parentheses#
        tmp.rp      <- which(tmp.ch %in% c(")"))                    ## location of right parentheses#
        tmp.ranks   <- tmp.ch[which(!(tmp.ch %in% c("(",")")))]     ## extract ranks#
        ## the if/then processes the hand based on the length, and#
        ## for single-suited suited hands it will use the location#
        ## of the right and left parentheses to assign the suits#
        ## double suited#
        if (tmp.nch == 8) {#
            tmp.suits   <- c("x","x","y","y")#
        ## single suited#
        } else if (tmp.nch == 6) {#
            ## (XY)ZW [1,4]#
            if ((tmp.lp == 1) & (tmp.rp == 4)) {#
                tmp.suits <- c("x","x","y","z")#
            ## X(YZ)W [2,5]#
            } else if ((tmp.lp == 2) & (tmp.rp == 5)) {#
                tmp.suits <- c("x","y","y","z")#
            ## XY(ZW) [3,6]#
            } else if ((tmp.lp == 3) & (tmp.rp == 6)) {#
                tmp.suits <- c("x","y","z","z")#
            ## (XYZ)W [1,5]#
            } else if ((tmp.lp == 1) & (tmp.rp == 5)) {#
                tmp.suits <- c("x","x","x","y")#
            ## X(YZW) [2,6]#
            } else if ((tmp.lp == 2) & (tmp.rp == 6)) {#
                tmp.suits <- c("x","y","y","y")#
            ## (XYZW) [1,6]#
            } else if ((tmp.lp == 1) & (tmp.rp == 6)) {#
                tmp.suits <- c("x","x","x","x")#
            }#
        ## rainbow#
        } else if (tmp.nch == 4) {#
            tmp.suits   <- c("x","y","z","w")#
        ## error#
        } else {#
            stop("unexpected string lenght\n")#
        }
tmp.ch
tmp.nch
tmp.lp
tmp.rp
tmp.ranks
seq(13, 1, 1)
seq(13, 1, -1)
## rank/num#
    tmp.rank    <- seq(13, 1, -1)#
    tmp.hand    <- c("A", "K", "Q", "J", "T", "9", "8", "7", "6", "5", "4", "3", "2")
cbind(tmp.rank, tmp.hand)
tmp.rank
tmp.hand
tmp.ranks
which(tmp.hand %in% tmp.ranks)
tmp.hand == tmp.ranks
match(tmp.ranks, tmp.hand)
tmp.hand[match(tmp.ranks, tmp.hand)]
tmp.rank[match(tmp.ranks, tmp.hand)]
tmp.ranks
sort(tmp.rank[match(tmp.ranks, tmp.hand)])
sort(tmp.rank[match(tmp.ranks, tmp.hand)], decreasing=TRUE)
##------------------------------------------------------------------#
## <function> rankToNum#
##------------------------------------------------------------------#
###
##------------------------------------------------------------------#
rankToNum <- function(n, r, hr) {#
    n[match(hr, r)]#
    return(sort(n[match(hr, r)], decreasing=TRUE))#
}
## rank/num#
    glob.num     <- seq(13, 1, -1)#
    glob.rank    <- c("A", "K", "Q", "J", "T", "9", "8", "7", "6", "5", "4", "3", "2")#
    ## process the filename#
    tmp.file    <- unlist(strsplit(in.file, "[.]"))#
    out.file    <- paste0(tmp.file[1], "_genericSyntax", ".", tmp.file[2])#
#
    ## read the input file and create an identically-sized output matrix#
    hf          <- read.csv(in.file, header=FALSE)#
    ho          <- matrix(,nrow=nrow(hf), ncol=1)
i <- 2
## process a hand#
        tmp.ch      <- unlist(strsplit(as.character(hf[i,]), ""))   ## split hand into individual characters#
        tmp.nch     <- length(tmp.ch)                               ## count number of characters#
        tmp.lp      <- which(tmp.ch %in% c("("))                    ## location of left parentheses#
        tmp.rp      <- which(tmp.ch %in% c(")"))                    ## location of right parentheses#
        tmp.ranks   <- tmp.ch[which(!(tmp.ch %in% c("(",")")))]     ## extract ranks
tmp.ranks
tmp.nums    <- rankToNum(glob.num, glob.rank, tmp.ranks)
tmp.nums
diff(tmp.nums)
unique(tmp.nums)
length(unique(tmp.nums))
table(tmp.ranks)
table(tmp.ranks)[1]
table(tmp.ranks)[2]
max(tmp.ranks)
max(table(tmp.ranks))
## rank/num#
    glob.num     <- seq(13, 1, -1)#
    glob.rank    <- c("A", "K", "Q", "J", "T", "9", "8", "7", "6", "5", "4", "3", "2")#
    ## process the filename#
    tmp.file    <- unlist(strsplit(in.file, "[.]"))#
    out.file    <- paste0(tmp.file[1], "_genericSyntax", ".", tmp.file[2])#
#
    ## read the input file and create an identically-sized output matrix#
    hf          <- read.csv(in.file, header=FALSE)#
    ho          <- matrix(,nrow=nrow(hf), ncol=1)#
    hs          <- matrix(,nrow=nrow(hf), ncol=1)#
#
    ## loop over each row in the file and process the ranked hand#
    for (i in 1:nrow(hf)) {#
        ## process a hand#
        tmp.ch      <- unlist(strsplit(as.character(hf[i,]), ""))   ## split hand into individual characters#
        tmp.nch     <- length(tmp.ch)                               ## count number of characters#
        tmp.lp      <- which(tmp.ch %in% c("("))                    ## location of left parentheses#
        tmp.rp      <- which(tmp.ch %in% c(")"))                    ## location of right parentheses#
        tmp.ranks   <- tmp.ch[which(!(tmp.ch %in% c("(",")")))]     ## extract ranks#
        ## get hand shape infp#
        tmp.nums    <- rankToNum(glob.num, glob.rank, tmp.ranks)    ## convert ranks to (sorted) numbers#
        tmp.gaps    <- diff(tmp.nums)                               ## calculate gap sizes#
        tmp.unq     <- length(unique(tmp.nums))                     ## number of unique#
        tmp.tbl     <- table(tmp.ranks)#
        ## the if/then processes the hand based on the length, and#
        ## for single-suited suited hands it will use the location#
        ## of the right and left parentheses to assign the suits#
        ## double suited#
        if (tmp.nch == 8) {#
            tmp.suits   <- c("x","x","y","y")#
            tmp.color   <- c("ds")#
        ## single suited#
        } else if (tmp.nch == 6) {#
            ## (XY)ZW [1,4]#
            if ((tmp.lp == 1) & (tmp.rp == 4)) {#
                tmp.suits   <- c("x","x","y","z")#
                tmp.color   <- c("ss")#
            ## X(YZ)W [2,5]#
            } else if ((tmp.lp == 2) & (tmp.rp == 5)) {#
                tmp.suits   <- c("x","y","y","z")#
                tmp.color   <- c("ss")#
            ## XY(ZW) [3,6]#
            } else if ((tmp.lp == 3) & (tmp.rp == 6)) {#
                tmp.suits   <- c("x","y","z","z")#
                tmp.color   <- c("ss")#
            ## (XYZ)W [1,5]#
            } else if ((tmp.lp == 1) & (tmp.rp == 5)) {#
                tmp.suits   <- c("x","x","x","y")#
                tmp.color   <- c("ss")#
            ## X(YZW) [2,6]#
            } else if ((tmp.lp == 2) & (tmp.rp == 6)) {#
                tmp.suits   <- c("x","y","y","y")#
                tmp.color   <- c("ss")#
            ## (XYZW) [1,6]#
            } else if ((tmp.lp == 1) & (tmp.rp == 6)) {#
                tmp.suits   <- c("x","x","x","x")#
                tmp.color   <- c("m")#
            }#
        ## rainbow#
        } else if (tmp.nch == 4) {#
            tmp.suits   <- c("x","y","z","w")#
            tmp.color   <- c("r")#
        ## error#
        } else {#
            stop("unexpected string lenght\n")#
        }#
    ## insert the hand translated into generic syntax to a matrix#
    ho[i,1]  <- appendSuits(tmp.ranks, tmp.suits)#
    hs[i,1]  <- tmp.color#
    }
head(ho)
head(hs)
tail(ho)
tail(hs)
table(hs)
tmp.color
tmp.unq
tmp.tbl
## rank/num#
    glob.num     <- seq(13, 1, -1)#
    glob.rank    <- c("A", "K", "Q", "J", "T", "9", "8", "7", "6", "5", "4", "3", "2")#
    ## process the filename#
    tmp.file    <- unlist(strsplit(in.file, "[.]"))#
    out.file    <- paste0(tmp.file[1], "_genericSyntax", ".", tmp.file[2])#
#
    ## read the input file and create an identically-sized output matrix#
    hf          <- read.csv(in.file, header=FALSE)#
    ho          <- matrix(,nrow=nrow(hf), ncol=1)#
    hs          <- matrix(,nrow=nrow(hf), ncol=2)#
#
    ## loop over each row in the file and process the ranked hand#
    for (i in 1:nrow(hf)) {#
        ## process a hand#
        tmp.ch      <- unlist(strsplit(as.character(hf[i,]), ""))   ## split hand into individual characters#
        tmp.nch     <- length(tmp.ch)                               ## count number of characters#
        tmp.lp      <- which(tmp.ch %in% c("("))                    ## location of left parentheses#
        tmp.rp      <- which(tmp.ch %in% c(")"))                    ## location of right parentheses#
        tmp.ranks   <- tmp.ch[which(!(tmp.ch %in% c("(",")")))]     ## extract ranks#
        ## get hand shape infp#
        tmp.nums    <- rankToNum(glob.num, glob.rank, tmp.ranks)    ## convert ranks to (sorted) numbers#
        tmp.gaps    <- diff(tmp.nums)                               ## calculate gap sizes#
        tmp.unq     <- length(unique(tmp.nums))                     ## number of unique#
        tmp.tbl     <- table(tmp.ranks)#
        ##------------------------------------------------------------------#
        ## the if/then processes the hand based on the length, and#
        ## for single-suited suited hands it will use the location#
        ## of the right and left parentheses to assign the suits#
        ##------------------------------------------------------------------#
        ## double suited#
        if (tmp.nch == 8) {#
            tmp.suits   <- c("x","x","y","y")#
            tmp.color   <- c("ds")#
        ## single suited#
        } else if (tmp.nch == 6) {#
            ## (XY)ZW [1,4]#
            if ((tmp.lp == 1) & (tmp.rp == 4)) {#
                tmp.suits   <- c("x","x","y","z")#
                tmp.color   <- c("ss")#
            ## X(YZ)W [2,5]#
            } else if ((tmp.lp == 2) & (tmp.rp == 5)) {#
                tmp.suits   <- c("x","y","y","z")#
                tmp.color   <- c("ss")#
            ## XY(ZW) [3,6]#
            } else if ((tmp.lp == 3) & (tmp.rp == 6)) {#
                tmp.suits   <- c("x","y","z","z")#
                tmp.color   <- c("ss")#
            ## (XYZ)W [1,5]#
            } else if ((tmp.lp == 1) & (tmp.rp == 5)) {#
                tmp.suits   <- c("x","x","x","y")#
                tmp.color   <- c("ss")#
            ## X(YZW) [2,6]#
            } else if ((tmp.lp == 2) & (tmp.rp == 6)) {#
                tmp.suits   <- c("x","y","y","y")#
                tmp.color   <- c("ss")#
            ## (XYZW) [1,6]#
            } else if ((tmp.lp == 1) & (tmp.rp == 6)) {#
                tmp.suits   <- c("x","x","x","x")#
                tmp.color   <- c("mo")#
            }#
        ## rainbow#
        } else if (tmp.nch == 4) {#
            tmp.suits   <- c("x","y","z","w")#
            tmp.color   <- c("rb")#
        ## error#
        } else {#
            stop("unexpected string lenght\n")#
        }#
        ##------------------------------------------------------------------#
        ###
        ##------------------------------------------------------------------#
        if (max(tmp.tbl) == 4) {#
            tmp.count   <- c("qu")#
        } else if (max(tmp.tbl) == 3) {#
            tmp.count   <- c("tr")#
        } else if (max(tmp.tbl == 2)) {#
            if (tmp.unq == 2) {#
                tmp.count   <- c("dp")#
            } else {#
                tmp.count   <- c("sp")#
            }#
        } else {#
            tmp.count   <- c("np")#
        }#
    ## insert the hand translated into generic syntax to a matrix#
    ho[i,1]  <- appendSuits(tmp.ranks, tmp.suits)#
    hs[i,1]  <- c(tmp.color, tmp.count)#
    }
c(tmp.color, tmp.count)
hs[i,]  <- c(tmp.color, tmp.count)
## rank/num#
    glob.num     <- seq(13, 1, -1)#
    glob.rank    <- c("A", "K", "Q", "J", "T", "9", "8", "7", "6", "5", "4", "3", "2")#
    ## process the filename#
    tmp.file    <- unlist(strsplit(in.file, "[.]"))#
    out.file    <- paste0(tmp.file[1], "_genericSyntax", ".", tmp.file[2])#
#
    ## read the input file and create an identically-sized output matrix#
    hf          <- read.csv(in.file, header=FALSE)#
    ho          <- matrix(,nrow=nrow(hf), ncol=1)#
    hs          <- matrix(,nrow=nrow(hf), ncol=2)#
#
    ## loop over each row in the file and process the ranked hand#
    for (i in 1:nrow(hf)) {#
        ## process a hand#
        tmp.ch      <- unlist(strsplit(as.character(hf[i,]), ""))   ## split hand into individual characters#
        tmp.nch     <- length(tmp.ch)                               ## count number of characters#
        tmp.lp      <- which(tmp.ch %in% c("("))                    ## location of left parentheses#
        tmp.rp      <- which(tmp.ch %in% c(")"))                    ## location of right parentheses#
        tmp.ranks   <- tmp.ch[which(!(tmp.ch %in% c("(",")")))]     ## extract ranks#
        ## get hand shape infp#
        tmp.nums    <- rankToNum(glob.num, glob.rank, tmp.ranks)    ## convert ranks to (sorted) numbers#
        tmp.gaps    <- diff(tmp.nums)                               ## calculate gap sizes#
        tmp.unq     <- length(unique(tmp.nums))                     ## number of unique#
        tmp.tbl     <- table(tmp.ranks)#
        ##------------------------------------------------------------------#
        ## the if/then processes the hand based on the length, and#
        ## for single-suited suited hands it will use the location#
        ## of the right and left parentheses to assign the suits#
        ##------------------------------------------------------------------#
        ## double suited#
        if (tmp.nch == 8) {#
            tmp.suits   <- c("x","x","y","y")#
            tmp.color   <- c("ds")#
        ## single suited#
        } else if (tmp.nch == 6) {#
            ## (XY)ZW [1,4]#
            if ((tmp.lp == 1) & (tmp.rp == 4)) {#
                tmp.suits   <- c("x","x","y","z")#
                tmp.color   <- c("ss")#
            ## X(YZ)W [2,5]#
            } else if ((tmp.lp == 2) & (tmp.rp == 5)) {#
                tmp.suits   <- c("x","y","y","z")#
                tmp.color   <- c("ss")#
            ## XY(ZW) [3,6]#
            } else if ((tmp.lp == 3) & (tmp.rp == 6)) {#
                tmp.suits   <- c("x","y","z","z")#
                tmp.color   <- c("ss")#
            ## (XYZ)W [1,5]#
            } else if ((tmp.lp == 1) & (tmp.rp == 5)) {#
                tmp.suits   <- c("x","x","x","y")#
                tmp.color   <- c("ss")#
            ## X(YZW) [2,6]#
            } else if ((tmp.lp == 2) & (tmp.rp == 6)) {#
                tmp.suits   <- c("x","y","y","y")#
                tmp.color   <- c("ss")#
            ## (XYZW) [1,6]#
            } else if ((tmp.lp == 1) & (tmp.rp == 6)) {#
                tmp.suits   <- c("x","x","x","x")#
                tmp.color   <- c("mo")#
            }#
        ## rainbow#
        } else if (tmp.nch == 4) {#
            tmp.suits   <- c("x","y","z","w")#
            tmp.color   <- c("rb")#
        ## error#
        } else {#
            stop("unexpected string lenght\n")#
        }#
        ##------------------------------------------------------------------#
        ###
        ##------------------------------------------------------------------#
        if (max(tmp.tbl) == 4) {#
            tmp.count   <- c("qu")#
        } else if (max(tmp.tbl) == 3) {#
            tmp.count   <- c("tr")#
        } else if (max(tmp.tbl == 2)) {#
            if (tmp.unq == 2) {#
                tmp.count   <- c("dp")#
            } else {#
                tmp.count   <- c("sp")#
            }#
        } else {#
            tmp.count   <- c("np")#
        }#
    ## insert the hand translated into generic syntax to a matrix#
    ho[i,1]  <- appendSuits(tmp.ranks, tmp.suits)#
    hs[i,]  <- c(tmp.color, tmp.count)#
    }
head(ho)
head(hs)
head(hs, 20)
head(ho, 20)
table(hs[,1], hs[,2])
sum(table(hs[,1], hs[,2]))
tmp.gaps
ho[1203,]
ho[1333,]
ho[2000,]
which(ho == "KxQyJxTy")
which(ho[,1] == "KxQyJxTy")
head(ho)
which(ho[,1] == "Kx")
which("Kx" %in% ho[,1])
which("KxQyJxTy" %in% ho[,1])
ho[,1]
ho[,1] == "KxQyJxTy"
sum(ho[,1] == "KxQyJxTy")
head(hf)
which(hf == "(KJ)(QT)")
ho[1149,]
i <- 1149
## rank/num#
    glob.num     <- seq(13, 1, -1)#
    glob.rank    <- c("A", "K", "Q", "J", "T", "9", "8", "7", "6", "5", "4", "3", "2")#
    ## process the filename#
    tmp.file    <- unlist(strsplit(in.file, "[.]"))#
    out.file    <- paste0(tmp.file[1], "_genericSyntax", ".", tmp.file[2])#
#
    ## read the input file and create an identically-sized output matrix#
    hf          <- read.csv(in.file, header=FALSE)#
    ho          <- matrix(,nrow=nrow(hf), ncol=1)#
    hs          <- matrix(,nrow=nrow(hf), ncol=2)
## process a hand#
        tmp.ch      <- unlist(strsplit(as.character(hf[i,]), ""))   ## split hand into individual characters#
        tmp.nch     <- length(tmp.ch)                               ## count number of characters#
        tmp.lp      <- which(tmp.ch %in% c("("))                    ## location of left parentheses#
        tmp.rp      <- which(tmp.ch %in% c(")"))                    ## location of right parentheses#
        tmp.ranks   <- tmp.ch[which(!(tmp.ch %in% c("(",")")))]     ## extract ranks#
        ## get hand shape infp#
        tmp.nums    <- rankToNum(glob.num, glob.rank, tmp.ranks)    ## convert ranks to (sorted) numbers#
        tmp.gaps    <- diff(tmp.nums)                               ## calculate gap sizes#
        tmp.unq     <- length(unique(tmp.nums))                     ## number of unique#
        tmp.tbl     <- table(tmp.ranks)
tmp.nums
tmp.gaps
abs(tmp.gaps)
tmp.tbl
tmp.unq
max(tmp.gaps)
tmp.gaps <- c(2, 1, 1)
tmp.gaps
max(tmp.gaps)
sum(tmp.gaps == 2)
sum(tmp.gaps == 2) == 1
tmp.gaps
paste0(tmp.gaps, collapse="")
## rank/num#
    glob.num     <- seq(13, 1, -1)#
    glob.rank    <- c("A", "K", "Q", "J", "T", "9", "8", "7", "6", "5", "4", "3", "2")#
    ## process the filename#
    tmp.file    <- unlist(strsplit(in.file, "[.]"))#
    out.file    <- paste0(tmp.file[1], "_genericSyntax", ".", tmp.file[2])#
#
    ## read the input file and create an identically-sized output matrix#
    hf          <- read.csv(in.file, header=FALSE)#
    ho          <- matrix(,nrow=nrow(hf), ncol=1)#
    hs          <- matrix(,nrow=nrow(hf), ncol=2)#
    hg          <- matrix(,nrow=nrow(hf), ncol=1)
## loop over each row in the file and process the ranked hand#
    for (i in 1:nrow(hf)) {#
        ## process a hand#
        tmp.ch      <- unlist(strsplit(as.character(hf[i,]), ""))   ## split hand into individual characters#
        tmp.nch     <- length(tmp.ch)                               ## count number of characters#
        tmp.lp      <- which(tmp.ch %in% c("("))                    ## location of left parentheses#
        tmp.rp      <- which(tmp.ch %in% c(")"))                    ## location of right parentheses#
        tmp.ranks   <- tmp.ch[which(!(tmp.ch %in% c("(",")")))]     ## extract ranks#
        ## get hand shape infp#
        tmp.nums    <- rankToNum(glob.num, glob.rank, tmp.ranks)    ## convert ranks to (sorted) numbers#
        tmp.gaps    <- abs(diff(tmp.nums))                          ## calculate gap sizes#
        tmp.unq     <- length(unique(tmp.nums))                     ## number of unique#
        tmp.tbl     <- table(tmp.ranks)#
        ##------------------------------------------------------------------#
        ## the if/then processes the hand based on the length, and#
        ## for single-suited suited hands it will use the location#
        ## of the right and left parentheses to assign the suits#
        ##------------------------------------------------------------------#
        ## double suited#
        if (tmp.nch == 8) {#
            tmp.suits   <- c("x","x","y","y")#
            tmp.color   <- c("ds")#
        ## single suited#
        } else if (tmp.nch == 6) {#
            ## (XY)ZW [1,4]#
            if ((tmp.lp == 1) & (tmp.rp == 4)) {#
                tmp.suits   <- c("x","x","y","z")#
                tmp.color   <- c("ss")#
            ## X(YZ)W [2,5]#
            } else if ((tmp.lp == 2) & (tmp.rp == 5)) {#
                tmp.suits   <- c("x","y","y","z")#
                tmp.color   <- c("ss")#
            ## XY(ZW) [3,6]#
            } else if ((tmp.lp == 3) & (tmp.rp == 6)) {#
                tmp.suits   <- c("x","y","z","z")#
                tmp.color   <- c("ss")#
            ## (XYZ)W [1,5]#
            } else if ((tmp.lp == 1) & (tmp.rp == 5)) {#
                tmp.suits   <- c("x","x","x","y")#
                tmp.color   <- c("ss")#
            ## X(YZW) [2,6]#
            } else if ((tmp.lp == 2) & (tmp.rp == 6)) {#
                tmp.suits   <- c("x","y","y","y")#
                tmp.color   <- c("ss")#
            ## (XYZW) [1,6]#
            } else if ((tmp.lp == 1) & (tmp.rp == 6)) {#
                tmp.suits   <- c("x","x","x","x")#
                tmp.color   <- c("mo")#
            }#
        ## rainbow#
        } else if (tmp.nch == 4) {#
            tmp.suits   <- c("x","y","z","w")#
            tmp.color   <- c("rb")#
        ## error#
        } else {#
            stop("unexpected string lenght\n")#
        }#
        ##------------------------------------------------------------------#
        ## characterize the number of duplicate ranks#
        ##------------------------------------------------------------------#
        if (max(tmp.tbl) == 4) {#
            tmp.count   <- c("qu")#
        } else if (max(tmp.tbl) == 3) {#
            tmp.count   <- c("tr")#
        } else if (max(tmp.tbl == 2)) {#
            if (tmp.unq == 2) {#
                tmp.count   <- c("dp")#
            } else {#
                tmp.count   <- c("sp")#
            }#
        } else {#
            ## no gaps#
            if (max(tmp.gaps) == 1) {#
                tmp.count   <- c("rundown")#
            ## single gaps#
            } else if (max(tmp.gaps) == 2) {#
                ## one gap only#
                if ((sum(tmp.gaps) == 2) == 1) {#
                    if (tmp.gaps[1] == 2) {#
                        tmp.count   <- c("top1gap")#
                    } else if (tmp.gaps[2] == 2) {#
                        tmp.count   <- c("mid1gap")#
                    } else if (tmp.gaps[3] == 2) {#
                        tmp.count   <- c("bot1gap")#
                    }#
                ## 2x one gap#
                } else if ((sum(tmp.gaps) == 2) == 2) {#
                    if (tmp.gaps[1] == 2 & tmp.gaps[2] == 2) {#
                        tmp.count   <- c("topmid1gap")#
                    } else if (tmp.gaps[1] == 2 & tmp.gaps[3] == 2) {#
                        tmp.count   <- c("topbot1gap")#
                    } else if (tmp.gaps[2] == 2 & tmp.gaps[3] == 2) {#
                        tmp.count   <- c("midbot11gap")#
                    }#
                ## 3x one gap#
                } else {#
                    tmp.count <- c("topmidbot1gap")#
                }#
            } else if (max(tmp.gaps) == 3) {#
            }#
            tmp.count   <- c("np")#
        }#
    ## insert the hand translated into generic syntax to a matrix#
    ho[i,1]  <- appendSuits(tmp.ranks, tmp.suits)#
    hs[i,]  <- c(tmp.color, tmp.count)#
    hg[i,1] <- paste0(tmp.gaps, collapse="")#
    }#
#
    ## save the output as a file#
    #write.table(ho, file=out.file, row.names=FALSE, col.names=FALSE)
table(hg)
tmp.nums
diff(tmp.nums)
sum(hg)
sum(table(hg))
table(hs[,2])
tmp.gaps
## rank/num#
    glob.num     <- seq(13, 1, -1)#
    glob.rank    <- c("A", "K", "Q", "J", "T", "9", "8", "7", "6", "5", "4", "3", "2")#
    ## process the filename#
    tmp.file    <- unlist(strsplit(in.file, "[.]"))#
    out.file    <- paste0(tmp.file[1], "_genericSyntax", ".", tmp.file[2])#
#
    ## read the input file and create an identically-sized output matrix#
    hf          <- read.csv(in.file, header=FALSE)#
    ho          <- matrix(,nrow=nrow(hf), ncol=1)#
    hs          <- matrix(,nrow=nrow(hf), ncol=2)#
    hg          <- matrix(,nrow=nrow(hf), ncol=1)#
#
    ## loop over each row in the file and process the ranked hand#
    for (i in 1:nrow(hf)) {#
        ## process a hand#
        tmp.ch      <- unlist(strsplit(as.character(hf[i,]), ""))   ## split hand into individual characters#
        tmp.nch     <- length(tmp.ch)                               ## count number of characters#
        tmp.lp      <- which(tmp.ch %in% c("("))                    ## location of left parentheses#
        tmp.rp      <- which(tmp.ch %in% c(")"))                    ## location of right parentheses#
        tmp.ranks   <- tmp.ch[which(!(tmp.ch %in% c("(",")")))]     ## extract ranks#
        ## get hand shape infp#
        tmp.nums    <- rankToNum(glob.num, glob.rank, tmp.ranks)    ## convert ranks to (sorted) numbers#
        tmp.gaps    <- abs(diff(tmp.nums))                          ## calculate gap sizes#
        tmp.unq     <- length(unique(tmp.nums))                     ## number of unique#
        tmp.tbl     <- table(tmp.ranks)#
        ##------------------------------------------------------------------#
        ## the if/then processes the hand based on the length, and#
        ## for single-suited suited hands it will use the location#
        ## of the right and left parentheses to assign the suits#
        ##------------------------------------------------------------------#
        ## double suited#
        if (tmp.nch == 8) {#
            tmp.suits   <- c("x","x","y","y")#
            tmp.color   <- c("ds")#
        ## single suited#
        } else if (tmp.nch == 6) {#
            ## (XY)ZW [1,4]#
            if ((tmp.lp == 1) & (tmp.rp == 4)) {#
                tmp.suits   <- c("x","x","y","z")#
                tmp.color   <- c("ss")#
            ## X(YZ)W [2,5]#
            } else if ((tmp.lp == 2) & (tmp.rp == 5)) {#
                tmp.suits   <- c("x","y","y","z")#
                tmp.color   <- c("ss")#
            ## XY(ZW) [3,6]#
            } else if ((tmp.lp == 3) & (tmp.rp == 6)) {#
                tmp.suits   <- c("x","y","z","z")#
                tmp.color   <- c("ss")#
            ## (XYZ)W [1,5]#
            } else if ((tmp.lp == 1) & (tmp.rp == 5)) {#
                tmp.suits   <- c("x","x","x","y")#
                tmp.color   <- c("ss")#
            ## X(YZW) [2,6]#
            } else if ((tmp.lp == 2) & (tmp.rp == 6)) {#
                tmp.suits   <- c("x","y","y","y")#
                tmp.color   <- c("ss")#
            ## (XYZW) [1,6]#
            } else if ((tmp.lp == 1) & (tmp.rp == 6)) {#
                tmp.suits   <- c("x","x","x","x")#
                tmp.color   <- c("mo")#
            }#
        ## rainbow#
        } else if (tmp.nch == 4) {#
            tmp.suits   <- c("x","y","z","w")#
            tmp.color   <- c("rb")#
        ## error#
        } else {#
            stop("unexpected string lenght\n")#
        }#
        ##------------------------------------------------------------------#
        ## characterize the number of duplicate ranks#
        ##------------------------------------------------------------------#
        if (max(tmp.tbl) == 4) {#
            tmp.count   <- c("qu")#
        } else if (max(tmp.tbl) == 3) {#
            tmp.count   <- c("tr")#
        } else if (max(tmp.tbl == 2)) {#
            if (tmp.unq == 2) {#
                tmp.count   <- c("dp")#
            } else {#
                tmp.count   <- c("sp")#
            }#
        } else {#
            ## no gaps#
            if (max(tmp.gaps) == 1) {#
                tmp.count   <- c("rundown")#
            ## single gaps#
            } else if (max(tmp.gaps) == 2) {#
                ## one gap only#
                if ((sum(tmp.gaps) == 2) == 1) {#
                    if (tmp.gaps[1] == 2) {#
                        tmp.count   <- c("top1gap")#
                    } else if (tmp.gaps[2] == 2) {#
                        tmp.count   <- c("mid1gap")#
                    } else if (tmp.gaps[3] == 2) {#
                        tmp.count   <- c("bot1gap")#
                    }#
                ## 2x one gap#
                } else if ((sum(tmp.gaps) == 2) == 2) {#
                    if (tmp.gaps[1] == 2 & tmp.gaps[2] == 2) {#
                        tmp.count   <- c("topmid1gap")#
                    } else if (tmp.gaps[1] == 2 & tmp.gaps[3] == 2) {#
                        tmp.count   <- c("topbot1gap")#
                    } else if (tmp.gaps[2] == 2 & tmp.gaps[3] == 2) {#
                        tmp.count   <- c("midbot11gap")#
                    }#
                ## 3x one gap#
                } else {#
                    tmp.count <- c("topmidbot1gap")#
                }#
            } else if (max(tmp.gaps) == 3) {#
            }#
            tmp.count   <- c("np")#
        }#
    ## insert the hand translated into generic syntax to a matrix#
    ho[i,1]  <- appendSuits(tmp.ranks, tmp.suits)#
    hs[i,]  <- c(tmp.color, tmp.count)#
    hg[i,1] <- paste0(tmp.gaps, collapse="")#
    }
table(hs[,1])
table(hs[,2])
tmp.gaps
tmp.nums
paste0(tmp.gaps, collapse=":")
## rank/num#
    glob.num     <- seq(13, 1, -1)#
    glob.rank    <- c("A", "K", "Q", "J", "T", "9", "8", "7", "6", "5", "4", "3", "2")#
    ## process the filename#
    tmp.file    <- unlist(strsplit(in.file, "[.]"))#
    out.file    <- paste0(tmp.file[1], "_genericSyntax", ".", tmp.file[2])#
#
    ## read the input file and create an identically-sized output matrix#
    hf          <- read.csv(in.file, header=FALSE)#
    ho          <- matrix(,nrow=nrow(hf), ncol=1)#
    hs          <- matrix(,nrow=nrow(hf), ncol=2)#
    hg          <- matrix(,nrow=nrow(hf), ncol=1)#
#
    ## loop over each row in the file and process the ranked hand#
    for (i in 1:nrow(hf)) {#
        ## process a hand#
        tmp.ch      <- unlist(strsplit(as.character(hf[i,]), ""))   ## split hand into individual characters#
        tmp.nch     <- length(tmp.ch)                               ## count number of characters#
        tmp.lp      <- which(tmp.ch %in% c("("))                    ## location of left parentheses#
        tmp.rp      <- which(tmp.ch %in% c(")"))                    ## location of right parentheses#
        tmp.ranks   <- tmp.ch[which(!(tmp.ch %in% c("(",")")))]     ## extract ranks#
        ## get hand shape infp#
        tmp.nums    <- rankToNum(glob.num, glob.rank, tmp.ranks)    ## convert ranks to (sorted) numbers#
        tmp.gaps    <- abs(diff(tmp.nums))                          ## calculate gap sizes#
        tmp.unq     <- length(unique(tmp.nums))                     ## number of unique#
        tmp.tbl     <- table(tmp.ranks)#
        ##------------------------------------------------------------------#
        ## the if/then processes the hand based on the length, and#
        ## for single-suited suited hands it will use the location#
        ## of the right and left parentheses to assign the suits#
        ##------------------------------------------------------------------#
        ## double suited#
        if (tmp.nch == 8) {#
            tmp.suits   <- c("x","x","y","y")#
            tmp.color   <- c("ds")#
        ## single suited#
        } else if (tmp.nch == 6) {#
            ## (XY)ZW [1,4]#
            if ((tmp.lp == 1) & (tmp.rp == 4)) {#
                tmp.suits   <- c("x","x","y","z")#
                tmp.color   <- c("ss")#
            ## X(YZ)W [2,5]#
            } else if ((tmp.lp == 2) & (tmp.rp == 5)) {#
                tmp.suits   <- c("x","y","y","z")#
                tmp.color   <- c("ss")#
            ## XY(ZW) [3,6]#
            } else if ((tmp.lp == 3) & (tmp.rp == 6)) {#
                tmp.suits   <- c("x","y","z","z")#
                tmp.color   <- c("ss")#
            ## (XYZ)W [1,5]#
            } else if ((tmp.lp == 1) & (tmp.rp == 5)) {#
                tmp.suits   <- c("x","x","x","y")#
                tmp.color   <- c("ss")#
            ## X(YZW) [2,6]#
            } else if ((tmp.lp == 2) & (tmp.rp == 6)) {#
                tmp.suits   <- c("x","y","y","y")#
                tmp.color   <- c("ss")#
            ## (XYZW) [1,6]#
            } else if ((tmp.lp == 1) & (tmp.rp == 6)) {#
                tmp.suits   <- c("x","x","x","x")#
                tmp.color   <- c("mo")#
            }#
        ## rainbow#
        } else if (tmp.nch == 4) {#
            tmp.suits   <- c("x","y","z","w")#
            tmp.color   <- c("rb")#
        ## error#
        } else {#
            stop("unexpected string lenght\n")#
        }#
        ##------------------------------------------------------------------#
        ## characterize the number of duplicate ranks#
        ##------------------------------------------------------------------#
        if (max(tmp.tbl) == 4) {#
            tmp.count   <- c("qu")#
        } else if (max(tmp.tbl) == 3) {#
            tmp.count   <- c("tr")#
        } else if (max(tmp.tbl == 2)) {#
            if (tmp.unq == 2) {#
                tmp.count   <- c("dp")#
            } else {#
                tmp.count   <- c("sp")#
            }#
        } else {#
            ## no gaps#
            if (max(tmp.gaps) == 1) {#
                tmp.count   <- c("rundown")#
            ## single gaps#
            } else if (max(tmp.gaps) == 2) {#
                ## one gap only#
                if ((sum(tmp.gaps) == 2) == 1) {#
                    if (tmp.gaps[1] == 2) {#
                        tmp.count   <- c("top1gap")#
                    } else if (tmp.gaps[2] == 2) {#
                        tmp.count   <- c("mid1gap")#
                    } else if (tmp.gaps[3] == 2) {#
                        tmp.count   <- c("bot1gap")#
                    }#
                ## 2x one gap#
                } else if ((sum(tmp.gaps) == 2) == 2) {#
                    if (tmp.gaps[1] == 2 & tmp.gaps[2] == 2) {#
                        tmp.count   <- c("topmid1gap")#
                    } else if (tmp.gaps[1] == 2 & tmp.gaps[3] == 2) {#
                        tmp.count   <- c("topbot1gap")#
                    } else if (tmp.gaps[2] == 2 & tmp.gaps[3] == 2) {#
                        tmp.count   <- c("midbot11gap")#
                    }#
                ## 3x one gap#
                } else {#
                    tmp.count <- c("topmidbot1gap")#
                }#
            } else if (max(tmp.gaps) == 3) {#
            }#
            tmp.count   <- c("np")#
        }#
    ## insert the hand translated into generic syntax to a matrix#
    ho[i,1]  <- appendSuits(tmp.ranks, tmp.suits)#
    hs[i,]  <- c(tmp.color, tmp.count)#
    hg[i,1] <- paste0(tmp.gaps, collapse=":")#
    }
table(hs[,2])
table(hs[,1])
table(hg[,1])
table(hg[,1], hs[,2])
tmp.gaps
any(tmp.gaps == 1)
any(tmp.gaps == 0)
tmp.gaps
tmp.gaps == 2
tmp.gaps <= 2
sum(tmp.gaps <= 2)
sum(tmp.gaps > 0)
all(tmp.gaps <= 3)
tmp.gaps
tmp.gaps[1]
tmp.gaps[1,3]
tmp.gaps[c(1,3)]
## rank/num#
    glob.num     <- seq(13, 1, -1)#
    glob.rank    <- c("A", "K", "Q", "J", "T", "9", "8", "7", "6", "5", "4", "3", "2")#
    ## process the filename#
    tmp.file    <- unlist(strsplit(in.file, "[.]"))#
    out.file    <- paste0(tmp.file[1], "_genericSyntax", ".", tmp.file[2])#
#
    ## read the input file and create an identically-sized output matrix#
    hf          <- read.csv(in.file, header=FALSE)#
    ho          <- matrix(,nrow=nrow(hf), ncol=1)#
    hs          <- matrix(,nrow=nrow(hf), ncol=2)#
    hg          <- matrix(,nrow=nrow(hf), ncol=1)#
#
    ## loop over each row in the file and process the ranked hand#
    for (i in 1:nrow(hf)) {#
        ## process a hand#
        tmp.ch      <- unlist(strsplit(as.character(hf[i,]), ""))   ## split hand into individual characters#
        tmp.nch     <- length(tmp.ch)                               ## count number of characters#
        tmp.lp      <- which(tmp.ch %in% c("("))                    ## location of left parentheses#
        tmp.rp      <- which(tmp.ch %in% c(")"))                    ## location of right parentheses#
        tmp.ranks   <- tmp.ch[which(!(tmp.ch %in% c("(",")")))]     ## extract ranks#
        ## get hand shape infp#
        tmp.nums    <- rankToNum(glob.num, glob.rank, tmp.ranks)    ## convert ranks to (sorted) numbers#
        tmp.gaps    <- abs(diff(tmp.nums))                          ## calculate gap sizes#
        tmp.unq     <- length(unique(tmp.nums))                     ## number of unique#
        tmp.tbl     <- table(tmp.ranks)#
        ##------------------------------------------------------------------#
        ## the if/then processes the hand based on the length, and#
        ## for single-suited suited hands it will use the location#
        ## of the right and left parentheses to assign the suits#
        ##------------------------------------------------------------------#
        ## double suited#
        if (tmp.nch == 8) {#
            tmp.suits   <- c("x","x","y","y")#
            tmp.color   <- c("ds")#
        ## single suited#
        } else if (tmp.nch == 6) {#
            ## (XY)ZW [1,4]#
            if ((tmp.lp == 1) & (tmp.rp == 4)) {#
                tmp.suits   <- c("x","x","y","z")#
                tmp.color   <- c("ss")#
            ## X(YZ)W [2,5]#
            } else if ((tmp.lp == 2) & (tmp.rp == 5)) {#
                tmp.suits   <- c("x","y","y","z")#
                tmp.color   <- c("ss")#
            ## XY(ZW) [3,6]#
            } else if ((tmp.lp == 3) & (tmp.rp == 6)) {#
                tmp.suits   <- c("x","y","z","z")#
                tmp.color   <- c("ss")#
            ## (XYZ)W [1,5]#
            } else if ((tmp.lp == 1) & (tmp.rp == 5)) {#
                tmp.suits   <- c("x","x","x","y")#
                tmp.color   <- c("ss")#
            ## X(YZW) [2,6]#
            } else if ((tmp.lp == 2) & (tmp.rp == 6)) {#
                tmp.suits   <- c("x","y","y","y")#
                tmp.color   <- c("ss")#
            ## (XYZW) [1,6]#
            } else if ((tmp.lp == 1) & (tmp.rp == 6)) {#
                tmp.suits   <- c("x","x","x","x")#
                tmp.color   <- c("mo")#
            }#
        ## rainbow#
        } else if (tmp.nch == 4) {#
            tmp.suits   <- c("x","y","z","w")#
            tmp.color   <- c("rb")#
        ## error#
        } else {#
            stop("unexpected string lenght\n")#
        }#
        ##------------------------------------------------------------------#
        ## characterize the number of duplicate ranks#
        ##------------------------------------------------------------------#
        if (max(tmp.tbl) == 4) {#
            tmp.count   <- c("qu")#
        } else if (max(tmp.tbl) == 3) {#
            tmp.count   <- c("tr")#
        } else if (max(tmp.tbl == 2)) {#
            if (tmp.unq == 2) {#
                tmp.count   <- c("dp")#
            } else {#
                tmp.count   <- c("sp")#
            }#
        } else {#
            ###
            if ( all(tmp.gaps <= 3) &  all(tmp.gaps > 0) ) {#
                ## rundown#
                if (all(tmp.gaps == 1)) {#
                    tmp.count <- c("rd")#
                ## single 1-gappers#
                } else if ( tmp.gaps[1] == 2 & all(tmp.gaps[c(2,3)] == 1)) {#
                    tmp.count <- c("t1g")#
                } else if ( tmp.gaps[2] == 2 & all(tmp.gaps[c(1,3)] == 1)) {#
                    tmp.count <- c("m1g")#
                } else if ( tmp.gaps[3] == 2 & all(tmp.gaps[c(1,2)] == 1)) {#
                    tmp.count <- c("b1g")#
                ## double 1-gappers#
                } else if ( all(tmp.gaps[c(1,2)] == 2) & tmp.gaps[3] == 1) {#
                    tmp.count <- c("tm1g")#
                } else if ( all(tmp.gaps[c(2,3)] == 2) & tmp.gaps[1] == 1) {#
                    tmp.count <- c("mb1g")#
                } else if ( all(tmp.gaps[c(1,3)] == 2) & tmp.gaps[2] == 1) {#
                    tmp.count <- c("tb1g")#
                } else if ( all(tmp.gaps == 2) ) {#
                    tmp.count <- c("tmb1g")#
                ## single 2-gappers#
                } else if ( tmp.gaps[1] == 3 & all(tmp.gaps[c(2,3)] == 1)) {#
                    tmp.count <- c("t2g")#
                } else if ( tmp.gaps[2] == 3 & all(tmp.gaps[c(1,3)] == 1)) {#
                    tmp.count <- c("m2g")#
                } else if ( tmp.gaps[3] == 3 & all(tmp.gaps[c(1,2)] == 1)) {#
                    tmp.count <- c("b2g")#
                ## double 2-gappers#
                } else if ( tmp.gaps[1] == 3 & all(tmp.gaps[c(2,3)] == 1)) {#
                    tmp.count <- c("t2g")#
                } else if ( tmp.gaps[2] == 3 & all(tmp.gaps[c(1,3)] == 1)) {#
                    tmp.count <- c("m2g")#
                } else if ( tmp.gaps[3] == 3 & all(tmp.gaps[c(1,2)] == 1)) {#
                    tmp.count <- c("b2g")#
                }#
            }#
            tmp.count   <- c("np")#
        }#
    ## insert the hand translated into generic syntax to a matrix#
    ho[i,1]  <- appendSuits(tmp.ranks, tmp.suits)#
    hs[i,]  <- c(tmp.color, tmp.count)#
    hg[i,1] <- paste0(tmp.gaps, collapse=":")#
    }
table(hs[,2])
## rank/num#
    glob.num     <- seq(13, 1, -1)#
    glob.rank    <- c("A", "K", "Q", "J", "T", "9", "8", "7", "6", "5", "4", "3", "2")#
    ## process the filename#
    tmp.file    <- unlist(strsplit(in.file, "[.]"))#
    out.file    <- paste0(tmp.file[1], "_genericSyntax", ".", tmp.file[2])#
#
    ## read the input file and create an identically-sized output matrix#
    hf          <- read.csv(in.file, header=FALSE)#
    ho          <- matrix(,nrow=nrow(hf), ncol=1)#
    hs          <- matrix(,nrow=nrow(hf), ncol=2)#
    hg          <- matrix(,nrow=nrow(hf), ncol=1)#
#
    ## loop over each row in the file and process the ranked hand#
    for (i in 1:nrow(hf)) {#
        ## process a hand#
        tmp.ch      <- unlist(strsplit(as.character(hf[i,]), ""))   ## split hand into individual characters#
        tmp.nch     <- length(tmp.ch)                               ## count number of characters#
        tmp.lp      <- which(tmp.ch %in% c("("))                    ## location of left parentheses#
        tmp.rp      <- which(tmp.ch %in% c(")"))                    ## location of right parentheses#
        tmp.ranks   <- tmp.ch[which(!(tmp.ch %in% c("(",")")))]     ## extract ranks#
        ## get hand shape infp#
        tmp.nums    <- rankToNum(glob.num, glob.rank, tmp.ranks)    ## convert ranks to (sorted) numbers#
        tmp.gaps    <- abs(diff(tmp.nums))                          ## calculate gap sizes#
        tmp.unq     <- length(unique(tmp.nums))                     ## number of unique#
        tmp.tbl     <- table(tmp.ranks)#
        ##------------------------------------------------------------------#
        ## the if/then processes the hand based on the length, and#
        ## for single-suited suited hands it will use the location#
        ## of the right and left parentheses to assign the suits#
        ##------------------------------------------------------------------#
        ## double suited#
        if (tmp.nch == 8) {#
            tmp.suits   <- c("x","x","y","y")#
            tmp.color   <- c("ds")#
        ## single suited#
        } else if (tmp.nch == 6) {#
            ## (XY)ZW [1,4]#
            if ((tmp.lp == 1) & (tmp.rp == 4)) {#
                tmp.suits   <- c("x","x","y","z")#
                tmp.color   <- c("ss")#
            ## X(YZ)W [2,5]#
            } else if ((tmp.lp == 2) & (tmp.rp == 5)) {#
                tmp.suits   <- c("x","y","y","z")#
                tmp.color   <- c("ss")#
            ## XY(ZW) [3,6]#
            } else if ((tmp.lp == 3) & (tmp.rp == 6)) {#
                tmp.suits   <- c("x","y","z","z")#
                tmp.color   <- c("ss")#
            ## (XYZ)W [1,5]#
            } else if ((tmp.lp == 1) & (tmp.rp == 5)) {#
                tmp.suits   <- c("x","x","x","y")#
                tmp.color   <- c("ss")#
            ## X(YZW) [2,6]#
            } else if ((tmp.lp == 2) & (tmp.rp == 6)) {#
                tmp.suits   <- c("x","y","y","y")#
                tmp.color   <- c("ss")#
            ## (XYZW) [1,6]#
            } else if ((tmp.lp == 1) & (tmp.rp == 6)) {#
                tmp.suits   <- c("x","x","x","x")#
                tmp.color   <- c("mo")#
            }#
        ## rainbow#
        } else if (tmp.nch == 4) {#
            tmp.suits   <- c("x","y","z","w")#
            tmp.color   <- c("rb")#
        ## error#
        } else {#
            stop("unexpected string lenght\n")#
        }#
        ##------------------------------------------------------------------#
        ## characterize the number of duplicate ranks#
        ##------------------------------------------------------------------#
        if (max(tmp.tbl) == 4) {#
            tmp.count   <- c("qu")#
        } else if (max(tmp.tbl) == 3) {#
            tmp.count   <- c("tr")#
        } else if (max(tmp.tbl == 2)) {#
            if (tmp.unq == 2) {#
                tmp.count   <- c("dp")#
            } else {#
                tmp.count   <- c("sp")#
            }#
        } else {#
            ###
            if ( all(tmp.gaps <= 3) &  all(tmp.gaps > 0) ) {#
                ## rundown#
                if (all(tmp.gaps == 1)) {#
                    tmp.count <- c("rd")#
                ## single 1-gappers#
                } else if ( tmp.gaps[1] == 2 & all(tmp.gaps[c(2,3)] == 1)) {#
                    tmp.count <- c("t1g")#
                } else if ( tmp.gaps[2] == 2 & all(tmp.gaps[c(1,3)] == 1)) {#
                    tmp.count <- c("m1g")#
                } else if ( tmp.gaps[3] == 2 & all(tmp.gaps[c(1,2)] == 1)) {#
                    tmp.count <- c("b1g")#
                ## double 1-gappers#
                } else if ( all(tmp.gaps[c(1,2)] == 2) & tmp.gaps[3] == 1) {#
                    tmp.count <- c("tm1g")#
                } else if ( all(tmp.gaps[c(2,3)] == 2) & tmp.gaps[1] == 1) {#
                    tmp.count <- c("mb1g")#
                } else if ( all(tmp.gaps[c(1,3)] == 2) & tmp.gaps[2] == 1) {#
                    tmp.count <- c("tb1g")#
                } else if ( all(tmp.gaps == 2) ) {#
                    tmp.count <- c("tmb1g")#
                ## single 2-gappers#
                } else if ( tmp.gaps[1] == 3 & all(tmp.gaps[c(2,3)] == 1)) {#
                    tmp.count <- c("t2g")#
                } else if ( tmp.gaps[2] == 3 & all(tmp.gaps[c(1,3)] == 1)) {#
                    tmp.count <- c("m2g")#
                } else if ( tmp.gaps[3] == 3 & all(tmp.gaps[c(1,2)] == 1)) {#
                    tmp.count <- c("b2g")#
                ## double 2-gappers#
                } else if ( tmp.gaps[1] == 3 & all(tmp.gaps[c(2,3)] == 1)) {#
                    tmp.count <- c("t2g")#
                } else if ( tmp.gaps[2] == 3 & all(tmp.gaps[c(1,3)] == 1)) {#
                    tmp.count <- c("m2g")#
                } else if ( tmp.gaps[3] == 3 & all(tmp.gaps[c(1,2)] == 1)) {#
                    tmp.count <- c("b2g")#
                }#
            } else {#
                tmp.count   <- c("np")#
            }#
        }#
    ## insert the hand translated into generic syntax to a matrix#
    ho[i,1]  <- appendSuits(tmp.ranks, tmp.suits)#
    hs[i,]  <- c(tmp.color, tmp.count)#
    hg[i,1] <- paste0(tmp.gaps, collapse=":")#
    }
table(hs[,2])
table(hg,hs[,2])
## "global" rank/number vectors#
    glob.num     <- seq(13, 1, -1)#
    glob.rank    <- c("A", "K", "Q", "J", "T", "9", "8", "7", "6", "5", "4", "3", "2")#
    ## process the filename#
    tmp.file    <- unlist(strsplit(in.file, "[.]"))#
    out.file    <- paste0(tmp.file[1], "_genericSyntax", ".", tmp.file[2])#
#
    ## read the input file and create an identically-sized output matrix#
    hf          <- read.csv(in.file, header=FALSE)#
    ho          <- matrix(,nrow=nrow(hf), ncol=1)#
    hs          <- matrix(,nrow=nrow(hf), ncol=2)#
    hg          <- matrix(,nrow=nrow(hf), ncol=1)#
#
    ## loop over each row in the file and process the ranked hand#
    for (i in 1:nrow(hf)) {#
        ## process a hand#
        tmp.ch      <- unlist(strsplit(as.character(hf[i,]), ""))   ## split hand into individual characters#
        tmp.nch     <- length(tmp.ch)                               ## count number of characters#
        tmp.lp      <- which(tmp.ch %in% c("("))                    ## location of left parentheses#
        tmp.rp      <- which(tmp.ch %in% c(")"))                    ## location of right parentheses#
        tmp.ranks   <- tmp.ch[which(!(tmp.ch %in% c("(",")")))]     ## extract ranks#
        ## get hand shape infp#
        tmp.nums    <- rankToNum(glob.num, glob.rank, tmp.ranks)    ## convert ranks to (sorted) numbers#
        tmp.gaps    <- abs(diff(tmp.nums))                          ## calculate gap sizes#
        tmp.unq     <- length(unique(tmp.nums))                     ## number of unique#
        tmp.tbl     <- table(tmp.ranks)#
        ##------------------------------------------------------------------#
        ## the if/then processes the hand based on the length, and#
        ## for single-suited suited hands it will use the location#
        ## of the right and left parentheses to assign the suits#
        ##------------------------------------------------------------------#
        ## double suited#
        if (tmp.nch == 8) {#
            tmp.suits   <- c("x","x","y","y")#
            tmp.color   <- c("ds")#
        ## single suited#
        } else if (tmp.nch == 6) {#
            ## (XY)ZW [1,4]#
            if ((tmp.lp == 1) & (tmp.rp == 4)) {#
                tmp.suits   <- c("x","x","y","z")#
                tmp.color   <- c("ss")#
            ## X(YZ)W [2,5]#
            } else if ((tmp.lp == 2) & (tmp.rp == 5)) {#
                tmp.suits   <- c("x","y","y","z")#
                tmp.color   <- c("ss")#
            ## XY(ZW) [3,6]#
            } else if ((tmp.lp == 3) & (tmp.rp == 6)) {#
                tmp.suits   <- c("x","y","z","z")#
                tmp.color   <- c("ss")#
            ## (XYZ)W [1,5]#
            } else if ((tmp.lp == 1) & (tmp.rp == 5)) {#
                tmp.suits   <- c("x","x","x","y")#
                tmp.color   <- c("ss")#
            ## X(YZW) [2,6]#
            } else if ((tmp.lp == 2) & (tmp.rp == 6)) {#
                tmp.suits   <- c("x","y","y","y")#
                tmp.color   <- c("ss")#
            ## (XYZW) [1,6]#
            } else if ((tmp.lp == 1) & (tmp.rp == 6)) {#
                tmp.suits   <- c("x","x","x","x")#
                tmp.color   <- c("mo")#
            }#
        ## rainbow#
        } else if (tmp.nch == 4) {#
            tmp.suits   <- c("x","y","z","w")#
            tmp.color   <- c("rb")#
        ## error#
        } else {#
            stop("unexpected string lenght\n")#
        }#
        ##------------------------------------------------------------------#
        ## characterize the number of duplicate ranks#
        ##------------------------------------------------------------------#
        if (max(tmp.tbl) == 4) {#
            tmp.count   <- c("qu")#
        } else if (max(tmp.tbl) == 3) {#
            tmp.count   <- c("tr")#
        } else if (max(tmp.tbl == 2)) {#
            if (tmp.unq == 2) {#
                tmp.count   <- c("dp")#
            } else {#
                tmp.count   <- c("sp")#
            }#
        } else {#
            ###
            if ( all(tmp.gaps <= 4) &  all(tmp.gaps > 0) ) {#
                ## rundown#
                if (all(tmp.gaps == 1)) {#
                    tmp.count <- c("rd")#
                ## single 1-gappers#
                } else if ( tmp.gaps[1] == 2 & all(tmp.gaps[c(2,3)] == 1)) {#
                    tmp.count <- c("t1g")#
                } else if ( tmp.gaps[2] == 2 & all(tmp.gaps[c(1,3)] == 1)) {#
                    tmp.count <- c("m1g")#
                } else if ( tmp.gaps[3] == 2 & all(tmp.gaps[c(1,2)] == 1)) {#
                    tmp.count <- c("b1g")#
                ## double 1-gappers#
                } else if ( all(tmp.gaps[c(1,2)] == 2) & tmp.gaps[3] == 1) {#
                    tmp.count <- c("tm1g")#
                } else if ( all(tmp.gaps[c(2,3)] == 2) & tmp.gaps[1] == 1) {#
                    tmp.count <- c("mb1g")#
                } else if ( all(tmp.gaps[c(1,3)] == 2) & tmp.gaps[2] == 1) {#
                    tmp.count <- c("tb1g")#
                ## triple 1-gapper#
                } else if ( all(tmp.gaps == 2) ) {#
                    tmp.count <- c("tmb1g")#
                ## single 2-gappers#
                } else if ( tmp.gaps[1] == 3 & all(tmp.gaps[c(2,3)] == 1)) {#
                    tmp.count <- c("t2g")#
                } else if ( tmp.gaps[2] == 3 & all(tmp.gaps[c(1,3)] == 1)) {#
                    tmp.count <- c("m2g")#
                } else if ( tmp.gaps[3] == 3 & all(tmp.gaps[c(1,2)] == 1)) {#
                    tmp.count <- c("b2g")#
                ## double 2-gappers#
                } else if ( tmp.gaps[1] == 3 & all(tmp.gaps[c(2,3)] == 1)) {#
                    tmp.count <- c("t2g")#
                } else if ( tmp.gaps[2] == 3 & all(tmp.gaps[c(1,3)] == 1)) {#
                    tmp.count <- c("m2g")#
                } else if ( tmp.gaps[3] == 3 & all(tmp.gaps[c(1,2)] == 1)) {#
                    tmp.count <- c("b2g")#
                ## triple 2-gapper#
                } else if ( all(tmp.gaps == 3) ) {#
                    tmp.count <- c("tmb2g")#
                ## single 3-gappers#
                } else if ( tmp.gaps[1] == 4 & all(tmp.gaps[c(2,3)] == 1)) {#
                    tmp.count <- c("t3g")#
                } else if ( tmp.gaps[2] == 4 & all(tmp.gaps[c(1,3)] == 1)) {#
                    tmp.count <- c("m3g")#
                } else if ( tmp.gaps[3] == 4 & all(tmp.gaps[c(1,2)] == 1)) {#
                    tmp.count <- c("b3g")#
                ## double 3-gappers#
                } else if ( tmp.gaps[1] == 4 & all(tmp.gaps[c(2,3)] == 1)) {#
                    tmp.count <- c("t3g")#
                } else if ( tmp.gaps[2] == 4 & all(tmp.gaps[c(1,3)] == 1)) {#
                    tmp.count <- c("m3g")#
                } else if ( tmp.gaps[3] == 4 & all(tmp.gaps[c(1,2)] == 1)) {#
                    tmp.count <- c("b3g")#
                ## triple 3-gapper#
                } else if ( all(tmp.gaps == 4) ) {#
                    tmp.count <- c("tmb3g")#
                }#
            } else {#
                tmp.count   <- c("np")#
            }#
        }#
    ## insert the hand translated into generic syntax to a matrix#
    ho[i,1]  <- appendSuits(tmp.ranks, tmp.suits)#
    hs[i,]  <- c(tmp.color, tmp.count)#
    hg[i,1] <- paste0(tmp.gaps, collapse=":")#
    }
head(hg)
head(hs)
head(ho)
head(cbind, ho, hs, hg)
head(cbind(ho, hs, hg))
(cbind(ho, hs, hg))tail
tail(cbind(ho, hs, hg))
tail(cbind(ho, hs, hg), 40L)
tail(cbind(ho, hs, hg), 100L)
a <- cbind(ho, hs, hg)
a[1149,]
a[1149:1180,]
## "global" rank/number vectors#
    glob.num     <- seq(13, 1, -1)#
    glob.rank    <- c("A", "K", "Q", "J", "T", "9", "8", "7", "6", "5", "4", "3", "2")#
    ## process the filename#
    tmp.file    <- unlist(strsplit(in.file, "[.]"))#
    out.file    <- paste0(tmp.file[1], "_genericSyntax", ".", tmp.file[2])#
#
    ## read the input file and create an identically-sized output matrix#
    hf          <- read.csv(in.file, header=FALSE)#
    ho          <- matrix(,nrow=nrow(hf), ncol=1)#
    hs          <- matrix(,nrow=nrow(hf), ncol=2)#
    hg          <- matrix(,nrow=nrow(hf), ncol=1)#
#
    ## loop over each row in the file and process the ranked hand#
    for (i in 1:nrow(hf)) {#
        ## process a hand#
        tmp.ch      <- unlist(strsplit(as.character(hf[i,]), ""))   ## split hand into individual characters#
        tmp.nch     <- length(tmp.ch)                               ## count number of characters#
        tmp.lp      <- which(tmp.ch %in% c("("))                    ## location of left parentheses#
        tmp.rp      <- which(tmp.ch %in% c(")"))                    ## location of right parentheses#
        tmp.ranks   <- tmp.ch[which(!(tmp.ch %in% c("(",")")))]     ## extract ranks#
        ## get hand shape infp#
        tmp.nums    <- rankToNum(glob.num, glob.rank, tmp.ranks)    ## convert ranks to (sorted) numbers#
        tmp.gaps    <- abs(diff(tmp.nums))                          ## calculate gap sizes#
        tmp.unq     <- length(unique(tmp.nums))                     ## number of unique#
        tmp.tbl     <- table(tmp.ranks)#
        ##------------------------------------------------------------------#
        ## the if/then processes the hand based on the length, and#
        ## for single-suited suited hands it will use the location#
        ## of the right and left parentheses to assign the suits#
        ##------------------------------------------------------------------#
        ## double suited#
        if (tmp.nch == 8) {#
            tmp.suits   <- c("x","x","y","y")#
            tmp.color   <- c("ds")#
        ## single suited#
        } else if (tmp.nch == 6) {#
            ## (XY)ZW [1,4]#
            if ((tmp.lp == 1) & (tmp.rp == 4)) {#
                tmp.suits   <- c("x","x","y","z")#
                tmp.color   <- c("ss")#
            ## X(YZ)W [2,5]#
            } else if ((tmp.lp == 2) & (tmp.rp == 5)) {#
                tmp.suits   <- c("x","y","y","z")#
                tmp.color   <- c("ss")#
            ## XY(ZW) [3,6]#
            } else if ((tmp.lp == 3) & (tmp.rp == 6)) {#
                tmp.suits   <- c("x","y","z","z")#
                tmp.color   <- c("ss")#
            ## (XYZ)W [1,5]#
            } else if ((tmp.lp == 1) & (tmp.rp == 5)) {#
                tmp.suits   <- c("x","x","x","y")#
                tmp.color   <- c("ss")#
            ## X(YZW) [2,6]#
            } else if ((tmp.lp == 2) & (tmp.rp == 6)) {#
                tmp.suits   <- c("x","y","y","y")#
                tmp.color   <- c("ss")#
            ## (XYZW) [1,6]#
            } else if ((tmp.lp == 1) & (tmp.rp == 6)) {#
                tmp.suits   <- c("x","x","x","x")#
                tmp.color   <- c("mo")#
            }#
        ## rainbow#
        } else if (tmp.nch == 4) {#
            tmp.suits   <- c("x","y","z","w")#
            tmp.color   <- c("rb")#
        ## error#
        } else {#
            stop("unexpected string lenght\n")#
        }#
        ##------------------------------------------------------------------#
        ## characterize the number of duplicate ranks#
        ##------------------------------------------------------------------#
        if (max(tmp.tbl) == 4) {#
            tmp.count   <- c("qu")#
        } else if (max(tmp.tbl) == 3) {#
            tmp.count   <- c("tr")#
        } else if (max(tmp.tbl == 2)) {#
            if (tmp.unq == 2) {#
                tmp.count   <- c("dp")#
            } else {#
                tmp.count   <- c("sp")#
            }#
        } else {#
            ###
            if ( all(tmp.gaps <= 4) &  all(tmp.gaps >= 0) ) {#
                ## rundown#
                if (all(tmp.gaps == 1)) {#
                    tmp.count <- c("rd")#
                ## connected pairs#
                } else if ( tmp.gaps[1] == 0 & all(tmp.gaps[c(2,3)] %in% c(1,2))) {#
                    tmp.count <- c("sp+c")#
                } else if ( tmp.gaps[2] == 0 & all(tmp.gaps[c(1,3)] %in% c(1,2))) {#
                    tmp.count <- c("sp+c")#
                } else if ( tmp.gaps[3] == 0 & all(tmp.gaps[c(1,2)] %in% c(1,2))) {#
                    tmp.count <- c("sp+c")#
                ## single 1-gappers#
                } else if ( tmp.gaps[1] == 2 & all(tmp.gaps[c(2,3)] == 1)) {#
                    tmp.count <- c("t1g")#
                } else if ( tmp.gaps[2] == 2 & all(tmp.gaps[c(1,3)] == 1)) {#
                    tmp.count <- c("m1g")#
                } else if ( tmp.gaps[3] == 2 & all(tmp.gaps[c(1,2)] == 1)) {#
                    tmp.count <- c("b1g")#
                ## double 1-gappers#
                } else if ( all(tmp.gaps[c(1,2)] == 2) & tmp.gaps[3] == 1) {#
                    tmp.count <- c("tm1g")#
                } else if ( all(tmp.gaps[c(2,3)] == 2) & tmp.gaps[1] == 1) {#
                    tmp.count <- c("mb1g")#
                } else if ( all(tmp.gaps[c(1,3)] == 2) & tmp.gaps[2] == 1) {#
                    tmp.count <- c("tb1g")#
                ## triple 1-gapper#
                } else if ( all(tmp.gaps == 2) ) {#
                    tmp.count <- c("tmb1g")#
                ## single 2-gappers#
                } else if ( tmp.gaps[1] == 3 & all(tmp.gaps[c(2,3)] == 1)) {#
                    tmp.count <- c("t2g")#
                } else if ( tmp.gaps[2] == 3 & all(tmp.gaps[c(1,3)] == 1)) {#
                    tmp.count <- c("m2g")#
                } else if ( tmp.gaps[3] == 3 & all(tmp.gaps[c(1,2)] == 1)) {#
                    tmp.count <- c("b2g")#
                ## double 2-gappers#
                } else if ( tmp.gaps[1] == 3 & all(tmp.gaps[c(2,3)] == 1)) {#
                    tmp.count <- c("t2g")#
                } else if ( tmp.gaps[2] == 3 & all(tmp.gaps[c(1,3)] == 1)) {#
                    tmp.count <- c("m2g")#
                } else if ( tmp.gaps[3] == 3 & all(tmp.gaps[c(1,2)] == 1)) {#
                    tmp.count <- c("b2g")#
                ## triple 2-gapper#
                } else if ( all(tmp.gaps == 3) ) {#
                    tmp.count <- c("tmb2g")#
                ## single 3-gappers#
                } else if ( tmp.gaps[1] == 4 & all(tmp.gaps[c(2,3)] == 1)) {#
                    tmp.count <- c("t3g")#
                } else if ( tmp.gaps[2] == 4 & all(tmp.gaps[c(1,3)] == 1)) {#
                    tmp.count <- c("m3g")#
                } else if ( tmp.gaps[3] == 4 & all(tmp.gaps[c(1,2)] == 1)) {#
                    tmp.count <- c("b3g")#
                ## double 3-gappers#
                } else if ( tmp.gaps[1] == 4 & all(tmp.gaps[c(2,3)] == 1)) {#
                    tmp.count <- c("t3g")#
                } else if ( tmp.gaps[2] == 4 & all(tmp.gaps[c(1,3)] == 1)) {#
                    tmp.count <- c("m3g")#
                } else if ( tmp.gaps[3] == 4 & all(tmp.gaps[c(1,2)] == 1)) {#
                    tmp.count <- c("b3g")#
                ## triple 3-gapper#
                } else if ( all(tmp.gaps == 4) ) {#
                    tmp.count <- c("tmb3g")#
                ## backstop#
                } else {#
                    tmp.count <- c("np")#
                }#
            } else {#
                tmp.count   <- c("np")#
            }#
        }#
    ## insert the hand translated into generic syntax to a matrix#
    ho[i,1]  <- appendSuits(tmp.ranks, tmp.suits)#
    hs[i,]  <- c(tmp.color, tmp.count)#
    hg[i,1] <- paste0(tmp.gaps, collapse=":")#
    }
hg[1149:1180,]
a <- cbind(ho, hs, hg)
a[1149:1180,]
a[1149:1280,]
##------------------------------------------------------------------#
## The purpose of this script is to parse the Pro Poker Tools (PPT)#
## hand ranking file #
##------------------------------------------------------------------#
#
##------------------------------------------------------------------#
## Clear the workspace#
##------------------------------------------------------------------#
rm(list=ls())#
#
##------------------------------------------------------------------#
## Set the working directory#
##------------------------------------------------------------------#
setwd("/Users/alexstephens/Development/poker/omaha_hi/data/pptoo/OmahaHi")#
#
##------------------------------------------------------------------#
## The PPT hands Omaha hands have the follow structures#
##------------------------------------------------------------------#
## XYZW#
## (XY)ZW#
## X(YZ)W#
## XY(ZW)#
## (XYZ)W#
## X(YZW)#
## (XYZW)#
## (XY)(ZW)#
##------------------------------------------------------------------#
#
##------------------------------------------------------------------#
## The goal is to convert these into the PPT generic syntax format#
##------------------------------------------------------------------#
## E.g., translate (AJ)(AJ) --> AxJxAyJy (double-suited double-pair)#
##------------------------------------------------------------------#
##------------------------------------------------------------------#
## <function> appendSuits#
##------------------------------------------------------------------#
## Takes a hand character vector, e.g., c("A","J","A","J") and#
## appends a suit character vector, e.g., c("x", "x", "y", "y")#
##------------------------------------------------------------------#
appendSuits <- function(h, s) {#
    return(paste(paste(h,s,sep=""), collapse=""))#
}#
#
##------------------------------------------------------------------#
## <function> rankToNum#
##------------------------------------------------------------------#
## Given a hand (e.g., c("A","J","A","J")), translate the ranks into#
## numerical equivalents (e.g., A=13, K=12, ... 3=2, 2=1)#
##------------------------------------------------------------------#
rankToNum <- function(n, r, hr) {#
    n[match(hr, r)]#
    return(sort(n[match(hr, r)], decreasing=TRUE))#
}#
##------------------------------------------------------------------#
## <function> processHandFile#
##------------------------------------------------------------------#
## Takes a PPT Omaha hand file as an input and writes the translated#
## format to a file.  The output filename contains the "_genericSyntax"#
## postfix.#
##------------------------------------------------------------------#
processHandFile <- function(in.file) {#
#
    ## "global" rank/number vectors#
    glob.num     <- seq(13, 1, -1)#
    glob.rank    <- c("A", "K", "Q", "J", "T", "9", "8", "7", "6", "5", "4", "3", "2")#
    ## process the filename#
    tmp.file    <- unlist(strsplit(in.file, "[.]"))#
    out.file    <- paste0(tmp.file[1], "_genericSyntax_DEBUG", ".", tmp.file[2])#
#
    ## read the input file and create an identically-sized output matrix#
    hf          <- read.csv(in.file, header=FALSE)#
    ho          <- matrix(,nrow=nrow(hf), ncol=1)#
    hs          <- matrix(,nrow=nrow(hf), ncol=2)#
    hg          <- matrix(,nrow=nrow(hf), ncol=1)#
#
    ## loop over each row in the file and process the ranked hand#
    for (i in 1:nrow(hf)) {#
        ## process a hand#
        tmp.ch      <- unlist(strsplit(as.character(hf[i,]), ""))   ## split hand into individual characters#
        tmp.nch     <- length(tmp.ch)                               ## count number of characters#
        tmp.lp      <- which(tmp.ch %in% c("("))                    ## location of left parentheses#
        tmp.rp      <- which(tmp.ch %in% c(")"))                    ## location of right parentheses#
        tmp.ranks   <- tmp.ch[which(!(tmp.ch %in% c("(",")")))]     ## extract ranks#
        ## get hand shape infp#
        tmp.nums    <- rankToNum(glob.num, glob.rank, tmp.ranks)    ## convert ranks to (sorted) numbers#
        tmp.gaps    <- abs(diff(tmp.nums))                          ## calculate gap sizes#
        tmp.unq     <- length(unique(tmp.nums))                     ## number of unique#
        tmp.tbl     <- table(tmp.ranks)#
        ##------------------------------------------------------------------#
        ## the if/then processes the hand based on the length, and#
        ## for single-suited suited hands it will use the location#
        ## of the right and left parentheses to assign the suits#
        ##------------------------------------------------------------------#
        ## double suited#
        if (tmp.nch == 8) {#
            tmp.suits   <- c("x","x","y","y")#
            tmp.color   <- c("ds")#
        ## single suited#
        } else if (tmp.nch == 6) {#
            ## (XY)ZW [1,4]#
            if ((tmp.lp == 1) & (tmp.rp == 4)) {#
                tmp.suits   <- c("x","x","y","z")#
                tmp.color   <- c("ss")#
            ## X(YZ)W [2,5]#
            } else if ((tmp.lp == 2) & (tmp.rp == 5)) {#
                tmp.suits   <- c("x","y","y","z")#
                tmp.color   <- c("ss")#
            ## XY(ZW) [3,6]#
            } else if ((tmp.lp == 3) & (tmp.rp == 6)) {#
                tmp.suits   <- c("x","y","z","z")#
                tmp.color   <- c("ss")#
            ## (XYZ)W [1,5]#
            } else if ((tmp.lp == 1) & (tmp.rp == 5)) {#
                tmp.suits   <- c("x","x","x","y")#
                tmp.color   <- c("ss")#
            ## X(YZW) [2,6]#
            } else if ((tmp.lp == 2) & (tmp.rp == 6)) {#
                tmp.suits   <- c("x","y","y","y")#
                tmp.color   <- c("ss")#
            ## (XYZW) [1,6]#
            } else if ((tmp.lp == 1) & (tmp.rp == 6)) {#
                tmp.suits   <- c("x","x","x","x")#
                tmp.color   <- c("mo")#
            }#
        ## rainbow#
        } else if (tmp.nch == 4) {#
            tmp.suits   <- c("x","y","z","w")#
            tmp.color   <- c("rb")#
        ## error#
        } else {#
            stop("unexpected string lenght\n")#
        }#
        ##------------------------------------------------------------------#
        ## characterize the number of duplicate ranks#
        ##------------------------------------------------------------------#
        if (max(tmp.tbl) == 4) {#
            tmp.count   <- c("qu")#
        } else if (max(tmp.tbl) == 3) {#
            tmp.count   <- c("tr")#
        } else if (max(tmp.tbl == 2)) {#
            if (tmp.unq == 2) {#
                tmp.count   <- c("dp")#
            } else {#
                tmp.count   <- c("sp")#
            }#
        } else {#
            ###
            if ( all(tmp.gaps <= 4) &  all(tmp.gaps >= 0) ) {#
    ## move the logic for pairs/trips/quads into this segment (under the 0 gap area)#
                ## rundown#
                if (all(tmp.gaps == 1)) {#
                    tmp.count <- c("rd")#
                ## connected pairs#
                } else if ( tmp.gaps[1] == 0 & all(tmp.gaps[c(2,3)] %in% c(1,2))) {#
                    tmp.count <- c("sp+c")#
                } else if ( tmp.gaps[2] == 0 & all(tmp.gaps[c(1,3)] %in% c(1,2))) {#
                    tmp.count <- c("sp+c")#
                } else if ( tmp.gaps[3] == 0 & all(tmp.gaps[c(1,2)] %in% c(1,2))) {#
                    tmp.count <- c("sp+c")#
                ## single 1-gappers#
                } else if ( tmp.gaps[1] == 2 & all(tmp.gaps[c(2,3)] == 1)) {#
                    tmp.count <- c("t1g")#
                } else if ( tmp.gaps[2] == 2 & all(tmp.gaps[c(1,3)] == 1)) {#
                    tmp.count <- c("m1g")#
                } else if ( tmp.gaps[3] == 2 & all(tmp.gaps[c(1,2)] == 1)) {#
                    tmp.count <- c("b1g")#
                ## double 1-gappers#
                } else if ( all(tmp.gaps[c(1,2)] == 2) & tmp.gaps[3] == 1) {#
                    tmp.count <- c("tm1g")#
                } else if ( all(tmp.gaps[c(2,3)] == 2) & tmp.gaps[1] == 1) {#
                    tmp.count <- c("mb1g")#
                } else if ( all(tmp.gaps[c(1,3)] == 2) & tmp.gaps[2] == 1) {#
                    tmp.count <- c("tb1g")#
                ## triple 1-gapper#
                } else if ( all(tmp.gaps == 2) ) {#
                    tmp.count <- c("tmb1g")#
                ## single 2-gappers#
                } else if ( tmp.gaps[1] == 3 & all(tmp.gaps[c(2,3)] == 1)) {#
                    tmp.count <- c("t2g")#
                } else if ( tmp.gaps[2] == 3 & all(tmp.gaps[c(1,3)] == 1)) {#
                    tmp.count <- c("m2g")#
                } else if ( tmp.gaps[3] == 3 & all(tmp.gaps[c(1,2)] == 1)) {#
                    tmp.count <- c("b2g")#
                ## double 2-gappers#
                } else if ( tmp.gaps[1] == 3 & all(tmp.gaps[c(2,3)] == 1)) {#
                    tmp.count <- c("t2g")#
                } else if ( tmp.gaps[2] == 3 & all(tmp.gaps[c(1,3)] == 1)) {#
                    tmp.count <- c("m2g")#
                } else if ( tmp.gaps[3] == 3 & all(tmp.gaps[c(1,2)] == 1)) {#
                    tmp.count <- c("b2g")#
                ## triple 2-gapper#
                } else if ( all(tmp.gaps == 3) ) {#
                    tmp.count <- c("tmb2g")#
                ## single 3-gappers#
                } else if ( tmp.gaps[1] == 4 & all(tmp.gaps[c(2,3)] == 1)) {#
                    tmp.count <- c("t3g")#
                } else if ( tmp.gaps[2] == 4 & all(tmp.gaps[c(1,3)] == 1)) {#
                    tmp.count <- c("m3g")#
                } else if ( tmp.gaps[3] == 4 & all(tmp.gaps[c(1,2)] == 1)) {#
                    tmp.count <- c("b3g")#
                ## double 3-gappers#
                } else if ( tmp.gaps[1] == 4 & all(tmp.gaps[c(2,3)] == 1)) {#
                    tmp.count <- c("t3g")#
                } else if ( tmp.gaps[2] == 4 & all(tmp.gaps[c(1,3)] == 1)) {#
                    tmp.count <- c("m3g")#
                } else if ( tmp.gaps[3] == 4 & all(tmp.gaps[c(1,2)] == 1)) {#
                    tmp.count <- c("b3g")#
                ## triple 3-gapper#
                } else if ( all(tmp.gaps == 4) ) {#
                    tmp.count <- c("tmb3g")#
                ## backstop#
                } else {#
                    tmp.count <- c("np")#
                }#
            } else {#
                tmp.count   <- c("np")#
            }#
        }#
    ## insert the hand translated into generic syntax to a matrix#
    ho[i,1]     <- appendSuits(tmp.ranks, tmp.suits)#
    hs[i,]      <- c(tmp.color, tmp.count)#
    hg[i,1]     <- paste0(tmp.gaps, collapse=":")#
    }#
#
    ## save the output as a file#
    #write.table(ho, file=out.file, row.names=FALSE, col.names=FALSE)#
    return(list(hf=hf, ho=ho, hs=hs, hg=hg))#
}#
##------------------------------------------------------------------#
## <main> process hands#
##------------------------------------------------------------------#
##processHandFile("ppt_plo_handrankings_03handed.txt")#
#
plo_6max.list   <- processHandFile("ppt_plo_handrankings_06handed.txt")#
#save(plo_6max.list, file="ppt_plo_handrankings_06handed.Rdata")#
#
##processHandFile("ppt_plo_handrankings_10handed.txt")#
##processHandFile("ppt_plo_handrankings_preflop_vs_random.txt")#
#
##------------------------------------------------------------------#
## Before#
##------------------------------------------------------------------#
## qp:data alexstephens$ head ppt_plo_handrankings_preflop_vs_random.txt#
## (AT)(AT)#
## (AJ)(AJ)#
## (AQ)(AQ)#
##------------------------------------------------------------------#
## After#
##------------------------------------------------------------------#
## qp:data alexstephens$ head ppt_plo_handrankings_preflop_vs_random_genericSyntax.txt#
## "AxTxAyTy"#
## "AxJxAyJy"#
## "AxQxAyQy"
str(plo_6max.list)
##------------------------------------------------------------------#
## The purpose of this script is to parse the Pro Poker Tools (PPT)#
## hand ranking file #
##------------------------------------------------------------------#
#
##------------------------------------------------------------------#
## Clear the workspace#
##------------------------------------------------------------------#
rm(list=ls())#
#
##------------------------------------------------------------------#
## Set the working directory#
##------------------------------------------------------------------#
setwd("/Users/alexstephens/Development/poker/omaha_hi/data/pptoo/OmahaHi")#
#
##------------------------------------------------------------------#
## The PPT hands Omaha hands have the follow structures#
##------------------------------------------------------------------#
## XYZW#
## (XY)ZW#
## X(YZ)W#
## XY(ZW)#
## (XYZ)W#
## X(YZW)#
## (XYZW)#
## (XY)(ZW)#
##------------------------------------------------------------------#
#
##------------------------------------------------------------------#
## The goal is to convert these into the PPT generic syntax format#
##------------------------------------------------------------------#
## E.g., translate (AJ)(AJ) --> AxJxAyJy (double-suited double-pair)#
##------------------------------------------------------------------#
##------------------------------------------------------------------#
## <function> appendSuits#
##------------------------------------------------------------------#
## Takes a hand character vector, e.g., c("A","J","A","J") and#
## appends a suit character vector, e.g., c("x", "x", "y", "y")#
##------------------------------------------------------------------#
appendSuits <- function(h, s) {#
    return(paste(paste(h,s,sep=""), collapse=""))#
}#
#
##------------------------------------------------------------------#
## <function> rankToNum#
##------------------------------------------------------------------#
## Given a hand (e.g., c("A","J","A","J")), translate the ranks into#
## numerical equivalents (e.g., A=13, K=12, ... 3=2, 2=1)#
##------------------------------------------------------------------#
rankToNum <- function(n, r, hr) {#
    n[match(hr, r)]#
    return(sort(n[match(hr, r)], decreasing=TRUE))#
}#
##------------------------------------------------------------------#
## <function> processHandFile#
##------------------------------------------------------------------#
## Takes a PPT Omaha hand file as an input and writes the translated#
## format to a file.  The output filename contains the "_genericSyntax"#
## postfix.#
##------------------------------------------------------------------#
processHandFile <- function(in.file) {#
#
    ## "global" rank/number vectors#
    glob.num     <- seq(13, 1, -1)#
    glob.rank    <- c("A", "K", "Q", "J", "T", "9", "8", "7", "6", "5", "4", "3", "2")#
    ## process the filename#
    tmp.file    <- unlist(strsplit(in.file, "[.]"))#
    out.file    <- paste0(tmp.file[1], "_genericSyntax_DEBUG", ".", tmp.file[2])#
#
    ## read the input file and create an identically-sized output matrix#
    hf          <- read.csv(in.file, header=FALSE)#
    ho          <- matrix(,nrow=nrow(hf), ncol=1)#
    hs          <- matrix(,nrow=nrow(hf), ncol=2)#
    hg          <- matrix(,nrow=nrow(hf), ncol=1)#
#
    ## loop over each row in the file and process the ranked hand#
    for (i in 1:nrow(hf)) {#
        ## process a hand#
        tmp.ch      <- unlist(strsplit(as.character(hf[i,]), ""))   ## split hand into individual characters#
        tmp.nch     <- length(tmp.ch)                               ## count number of characters#
        tmp.lp      <- which(tmp.ch %in% c("("))                    ## location of left parentheses#
        tmp.rp      <- which(tmp.ch %in% c(")"))                    ## location of right parentheses#
        tmp.ranks   <- tmp.ch[which(!(tmp.ch %in% c("(",")")))]     ## extract ranks#
        ## get hand shape infp#
        tmp.nums    <- rankToNum(glob.num, glob.rank, tmp.ranks)    ## convert ranks to (sorted) numbers#
        tmp.gaps    <- abs(diff(tmp.nums))                          ## calculate gap sizes#
        tmp.unq     <- length(unique(tmp.nums))                     ## number of unique#
        tmp.tbl     <- table(tmp.ranks)#
        ##------------------------------------------------------------------#
        ## the if/then processes the hand based on the length, and#
        ## for single-suited suited hands it will use the location#
        ## of the right and left parentheses to assign the suits#
        ##------------------------------------------------------------------#
        ## double suited#
        if (tmp.nch == 8) {#
            tmp.suits   <- c("x","x","y","y")#
            tmp.color   <- c("ds")#
        ## single suited#
        } else if (tmp.nch == 6) {#
            ## (XY)ZW [1,4]#
            if ((tmp.lp == 1) & (tmp.rp == 4)) {#
                tmp.suits   <- c("x","x","y","z")#
                tmp.color   <- c("ss")#
            ## X(YZ)W [2,5]#
            } else if ((tmp.lp == 2) & (tmp.rp == 5)) {#
                tmp.suits   <- c("x","y","y","z")#
                tmp.color   <- c("ss")#
            ## XY(ZW) [3,6]#
            } else if ((tmp.lp == 3) & (tmp.rp == 6)) {#
                tmp.suits   <- c("x","y","z","z")#
                tmp.color   <- c("ss")#
            ## (XYZ)W [1,5]#
            } else if ((tmp.lp == 1) & (tmp.rp == 5)) {#
                tmp.suits   <- c("x","x","x","y")#
                tmp.color   <- c("ss")#
            ## X(YZW) [2,6]#
            } else if ((tmp.lp == 2) & (tmp.rp == 6)) {#
                tmp.suits   <- c("x","y","y","y")#
                tmp.color   <- c("ss")#
            ## (XYZW) [1,6]#
            } else if ((tmp.lp == 1) & (tmp.rp == 6)) {#
                tmp.suits   <- c("x","x","x","x")#
                tmp.color   <- c("mo")#
            }#
        ## rainbow#
        } else if (tmp.nch == 4) {#
            tmp.suits   <- c("x","y","z","w")#
            tmp.color   <- c("rb")#
        ## error#
        } else {#
            stop("unexpected string lenght\n")#
        }#
        ##------------------------------------------------------------------#
        ## characterize the number of duplicate ranks#
        ##------------------------------------------------------------------#
        if (max(tmp.tbl) == 4) {#
            tmp.count   <- c("qu")#
        } else if (max(tmp.tbl) == 3) {#
            tmp.count   <- c("tr")#
        } else if (max(tmp.tbl == 2)) {#
            if (tmp.unq == 2) {#
                tmp.count   <- c("dp")#
            } else {#
                tmp.count   <- c("sp")#
            }#
        } else {#
            ###
            if ( all(tmp.gaps <= 4) &  all(tmp.gaps >= 0) ) {#
    ## move the logic for pairs/trips/quads into this segment (under the 0 gap area)#
                ## rundown#
                if (all(tmp.gaps == 1)) {#
                    tmp.count <- c("rd")#
                ## connected pairs#
                } else if ( tmp.gaps[1] == 0 & all(tmp.gaps[c(2,3)] %in% c(1,2))) {#
                    tmp.count <- c("sp+c")#
                } else if ( tmp.gaps[2] == 0 & all(tmp.gaps[c(1,3)] %in% c(1,2))) {#
                    tmp.count <- c("sp+c")#
                } else if ( tmp.gaps[3] == 0 & all(tmp.gaps[c(1,2)] %in% c(1,2))) {#
                    tmp.count <- c("sp+c")#
                ## single 1-gappers#
                } else if ( tmp.gaps[1] == 2 & all(tmp.gaps[c(2,3)] == 1)) {#
                    tmp.count <- c("t1g")#
                } else if ( tmp.gaps[2] == 2 & all(tmp.gaps[c(1,3)] == 1)) {#
                    tmp.count <- c("m1g")#
                } else if ( tmp.gaps[3] == 2 & all(tmp.gaps[c(1,2)] == 1)) {#
                    tmp.count <- c("b1g")#
                ## double 1-gappers#
                } else if ( all(tmp.gaps[c(1,2)] == 2) & tmp.gaps[3] == 1) {#
                    tmp.count <- c("tm1g")#
                } else if ( all(tmp.gaps[c(2,3)] == 2) & tmp.gaps[1] == 1) {#
                    tmp.count <- c("mb1g")#
                } else if ( all(tmp.gaps[c(1,3)] == 2) & tmp.gaps[2] == 1) {#
                    tmp.count <- c("tb1g")#
                ## triple 1-gapper#
                } else if ( all(tmp.gaps == 2) ) {#
                    tmp.count <- c("tmb1g")#
                ## single 2-gappers#
                } else if ( tmp.gaps[1] == 3 & all(tmp.gaps[c(2,3)] == 1)) {#
                    tmp.count <- c("t2g")#
                } else if ( tmp.gaps[2] == 3 & all(tmp.gaps[c(1,3)] == 1)) {#
                    tmp.count <- c("m2g")#
                } else if ( tmp.gaps[3] == 3 & all(tmp.gaps[c(1,2)] == 1)) {#
                    tmp.count <- c("b2g")#
                ## double 2-gappers#
                } else if ( tmp.gaps[1] == 3 & all(tmp.gaps[c(2,3)] == 1)) {#
                    tmp.count <- c("t2g")#
                } else if ( tmp.gaps[2] == 3 & all(tmp.gaps[c(1,3)] == 1)) {#
                    tmp.count <- c("m2g")#
                } else if ( tmp.gaps[3] == 3 & all(tmp.gaps[c(1,2)] == 1)) {#
                    tmp.count <- c("b2g")#
                ## triple 2-gapper#
                } else if ( all(tmp.gaps == 3) ) {#
                    tmp.count <- c("tmb2g")#
                ## single 3-gappers#
                } else if ( tmp.gaps[1] == 4 & all(tmp.gaps[c(2,3)] == 1)) {#
                    tmp.count <- c("t3g")#
                } else if ( tmp.gaps[2] == 4 & all(tmp.gaps[c(1,3)] == 1)) {#
                    tmp.count <- c("m3g")#
                } else if ( tmp.gaps[3] == 4 & all(tmp.gaps[c(1,2)] == 1)) {#
                    tmp.count <- c("b3g")#
                ## double 3-gappers#
                } else if ( tmp.gaps[1] == 4 & all(tmp.gaps[c(2,3)] == 1)) {#
                    tmp.count <- c("t3g")#
                } else if ( tmp.gaps[2] == 4 & all(tmp.gaps[c(1,3)] == 1)) {#
                    tmp.count <- c("m3g")#
                } else if ( tmp.gaps[3] == 4 & all(tmp.gaps[c(1,2)] == 1)) {#
                    tmp.count <- c("b3g")#
                ## triple 3-gapper#
                } else if ( all(tmp.gaps == 4) ) {#
                    tmp.count <- c("tmb3g")#
                ## backstop#
                } else {#
                    tmp.count <- c("np")#
                }#
            } else {#
                tmp.count   <- c("np")#
            }#
        }#
    ## insert the hand translated into generic syntax to a matrix#
    ho[i,1]     <- appendSuits(tmp.ranks, tmp.suits)#
    hs[i,]      <- c(tmp.color, tmp.count)#
    hg[i,1]     <- paste0(tmp.gaps, collapse=":")#
    }#
#
    ## save the output as a file#
    #write.table(ho, file=out.file, row.names=FALSE, col.names=FALSE)#
    return(list(hf=hf, ho=ho, hs=hs, hg=hg))#
}#
##------------------------------------------------------------------#
## <main> process hands#
##------------------------------------------------------------------#
#
##processHandFile("ppt_plo_handrankings_03handed.txt")#
#
plo_6max.list   <- processHandFile("ppt_plo_handrankings_06handed.txt")#
save(plo_6max.list, file="ppt_plo_handrankings_06handed.Rdata")#
#
##processHandFile("ppt_plo_handrankings_10handed.txt")#
##processHandFile("ppt_plo_handrankings_preflop_vs_random.txt")#
##------------------------------------------------------------------#
## Before#
##------------------------------------------------------------------#
## qp:data alexstephens$ head ppt_plo_handrankings_preflop_vs_random.txt#
## (AT)(AT)#
## (AJ)(AJ)#
## (AQ)(AQ)#
##------------------------------------------------------------------#
## After#
##------------------------------------------------------------------#
## qp:data alexstephens$ head ppt_plo_handrankings_preflop_vs_random_genericSyntax.txt#
## "AxTxAyTy"#
## "AxJxAyJy"#
## "AxQxAyQy"
getwd()
load("../simulations/hotColdEquity_6max_OmahaHi_AllHands.Rdata")
load("../../simulations/hotColdEquity_6max_OmahaHi_AllHands.Rdata")
getwd()
load("../../simulations/hotColdEquity_6max_OmahiHi_AllHands.Rdata")
ls()
head(res.mat)
names(plo_6max.list)
a <- cbind(plo_6max.list[["ho"]], plo_6max.list[["hs"]], plo_6max.list[["hg"]])
head(a)
head(res.mat)
which(res.mat[,1] > 0.5)
a <- which(res.mat[,3] > 0.5)
lenght(a)
a
length(a)
b <- which(res.mat[,3] > 0.5)
a <- cbind(plo_6max.list[["ho"]], plo_6max.list[["hs"]], plo_6max.list[["hg"]])
a[b,]
c <- a[b,]
head(a)
table(c[,2],c[,3])
d <- table(c[,2],c[,3])
apply(d,1,sum)
head(res.mat)
sim(res.mat)
dim(res.mat)
dim(c)
922/16432
q()
