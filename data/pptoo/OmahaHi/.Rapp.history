lc$hclust$height
q)()
q()
##------------------------------------------------------------------#
## Load libraries#
##------------------------------------------------------------------#
library(igraph)                 ## contains graph functions#
library(linkcomm)               ## contains link community functions#
library(dendextend)             ## contains dendrogram functions#
library(caTools)#
librart(gdata)#
#
##------------------------------------------------------------------#
## Clear the workspace#
##------------------------------------------------------------------#
rm(list=ls())#
#
##------------------------------------------------------------------#
## Load utility functions#
##------------------------------------------------------------------#
source("/Users/alexstephens/Development/kaggle/social_circle/k_soc/00_Utilities.r")#
##------------------------------------------------------------------#
## Benchmark: Les Miserables characters connected graph#
##------------------------------------------------------------------#
#
## load the raw dataset (from linkcomm())#
lm <- lesmiserables#
#
##------------------------------------------------------------------#
## Step 1:  This is somewhat redundant, but translate the Les Mis#
## factor/edge list into the egonet structure that I've loaded#
## from the kaggle competition.#
##------------------------------------------------------------------#
#
## convert the data of factors into characters#
tmp.lm <- convert.magic(lm, c("V1","V2"), c("character","character"))#
#
## map character names to integers#
nodes_l.uniq    <- unique(tmp.lm$V1)#
nodes_r.uniq    <- unique(tmp.lm$V2)#
characters.uniq <- union(nodes_l.uniq, nodes_r.uniq)#
characters.ids  <- 1:length(characters.uniq)#
#
## define the egonet#
lm.egonet  <- list()#
#
## load the egonet#
for (i in 1:length(nodes_l.uniq)) {#
    ## get a vertex & assign an id#
    tmp.node    <- nodes_l.uniq[i]#
    tmp.id      <- characters.ids[ which(characters.uniq == tmp.node)]#
    char.id     <- paste("ID_",tmp.id,sep="")#
    ## get the list of characters (and their ids) associated with this vertex#
    lm.egonet[[char.id]] <- paste("ID_", characters.ids[ which(characters.uniq %in% tmp.lm$V2[which(tmp.lm$V1 == tmp.node)]) ], sep="")#
}#
#
##------------------------------------------------------------------#
## Step 2:  At this point, the Les Mis data are in a format that#
## is similar to the loaded kaggle data format. Load the raw data#
## into an igraph object#
##------------------------------------------------------------------#
lm.igraph   <- convEgonetListToIgraphObject(lm.egonet)#
##------------------------------------------------------------------#
## Step 3:  Compute the dissimilarity measure amongst the clusters.#
## The similarity measure is the Jaccard coefficient. The Jaccard#
## *distance* is 1 minus the Jaccard coefficient.#
##------------------------------------------------------------------#
#
lm.sim      <- calcSimilarityMatrix(lm.igraph)  ## similarity matrix#
lm.dis      <- 1 - lm.sim                       ## jaccard distance#
#
##------------------------------------------------------------------#
## Step 3:  Compute the cluster#
##------------------------------------------------------------------#
#
## create a distance object from the dissimilarity matrix#
lm.dist     <- as.dist(lm.dis)#
#
## compute a cluster#
lm.clust    <- hclust(lm.dist, method="single")#
lm.dend     <- as.dendrogram(lm.clust)#
##------------------------------------------------------------------#
## Step 4:  Verify cluster output using linkcomm() [ok]#
##------------------------------------------------------------------#
#
## use linkcomm() to compute the cluster#
lm.lc       <- getLinkCommunities(get.data.frame(lm.igraph,"edges"), hcmethod="single")#
comp.clust  <- cbind(lm.lc$hclust$height, lm.clust$height, lm.lc$hclust$height-lm.clust$height)#
##------------------------------------------------------------------#
## Step 4:  Verify cluster output using linkcomm() [ok]#
##------------------------------------------------------------------#
#
hh <- unique(round(lm.clust$height, digits = 5)) # Round to 5 digits to prevent numerical instability affecting community formation.#
#
## just counts the number of edges at each height#
## number of heights = 50#
## sum of countClusters = 253 = distance lenght#
countClusters <- function(x, ht)#
{#
    return(length(which(ht==x)))#
}#
clusnums <- sapply(hh, countClusters, ht = round(lm.clust$height, digits = 5)) # Number of clusters at each height.#
#
## want to find the "optimal" height using the cluster density#
#for (i in 1:length(unique(lm.clust$height))) {#
    tmp.height  <- unique(lm.clust$height)[20]#
    tmp.clus    <-  cutree(lm.clust, h=tmp.height)#
#}#
## define a matrix to hold cluster membership at each height#
hgts        <- unique(lm.clust$height)#
hgts.num    <- length(hgts)#
edges.num   <- nrow(get.edgelist(lm.igraph))#
#
## define & load the matrix#
tmp.mat <- matrix(0, nrow=edges.num, ncol=hgts.num)#
for (i in 1:hgts.num) {#
    tmp.mat[,i] <- as.vector(cutree(lm.clust, h=hgts[i]))#
}#
#
## get the number of groups at each height#
groups.vec <- vector(, length=hgts.num)#
for (i in 1:hgts.num) {#
    groups.vec[i] <- length(unique(tmp.mat[,i]))#
}
for (i in 1:hgts.num) {#
    groups.uniq <- unique(tmp.mat[,i])#
    groups.num  <- length(groups.uniq)#
#
    for (j in 1:groups.num) {#
        tmp.idx     <- which(tmp.mat[,i] == groups.num[j])#
        tmp.memb    <- union(get.edgelist(lm.igraph)[tmp.idx,1], get.edgelist(lm.igraph)[tmp.idx,2])#
    }#
    ## NEXT STEP IS TO REVIEW THE DENSITY FORMULA WITH A CLEAR HEAD#
}
tmp.memb
tmp.mat
i
tmp.idx
tmp.memb
length(tmp.memb)
tmp.idx
length(tmp.idx)
## loop over each height and then the groups#
dens.vec    <- vector(, length=hgts.num)#
#
for (i in 1:hgts.num) {#
    groups.uniq <- unique(tmp.mat[,i])#
    groups.num  <- length(groups.uniq)#
#
    tmp.dens <- 0#
    for (j in 1:groups.num) {#
        tmp.idx     <- which(tmp.mat[,i] == groups.num[j])#
        tmp.memb    <- union(get.edgelist(lm.igraph)[tmp.idx,1], get.edgelist(lm.igraph)[tmp.idx,2])#
        tmp.mc      <- length(tmp.idx)#
        tmp.nc      <- length(tmp.memb)#
        if (nc > 2) {#
            tmp.dens    <- tmp.dens + 2*(tmp.mc - (tmp.nc-1))/(edges.num*(tmp.nc-2)*(tmp.nc-1))#
        }#
    }#
    dens.vec[i] <- tmp.dens#
    ## NEXT STEP IS TO REVIEW THE DENSITY FORMULA WITH A CLEAR HEAD#
}
## loop over each height and then the groups#
dens.vec    <- vector(, length=hgts.num)#
#
for (i in 1:hgts.num) {#
    groups.uniq <- unique(tmp.mat[,i])#
    groups.num  <- length(groups.uniq)#
#
    tmp.dens <- 0#
    for (j in 1:groups.num) {#
        tmp.idx     <- which(tmp.mat[,i] == groups.num[j])#
        tmp.memb    <- union(get.edgelist(lm.igraph)[tmp.idx,1], get.edgelist(lm.igraph)[tmp.idx,2])#
        tmp.mc      <- length(tmp.idx)#
        tmp.nc      <- length(tmp.memb)#
        if (tmp.nc > 2) {#
            tmp.dens    <- tmp.dens + 2*(tmp.mc - (tmp.nc-1))/(edges.num*(tmp.nc-2)*(tmp.nc-1))#
        }#
    }#
    dens.vec[i] <- tmp.dens#
    ## NEXT STEP IS TO REVIEW THE DENSITY FORMULA WITH A CLEAR HEAD#
}
dens.vec
j
i <- 38
groups.uniq <- unique(tmp.mat[,i])#
    groups.num  <- length(groups.uniq)
groups.uniq
groups.num
table(tmp.mat[,i])
i <- 1
i <- 38
j <- 1
tmp.idx     <- which(tmp.mat[,i] == groups.num[j])#
        tmp.memb    <- union(get.edgelist(lm.igraph)[tmp.idx,1], get.edgelist(lm.igraph)[tmp.idx,2])
tmp.idx
groups.uniq
tmp.idx     <- which(tmp.mat[,i] == groups.uniq[j])#
        tmp.memb    <- union(get.edgelist(lm.igraph)[tmp.idx,1], get.edgelist(lm.igraph)[tmp.idx,2])#
        tmp.mc      <- length(tmp.idx)#
        tmp.nc      <- length(tmp.memb)
tmp.idx
tmp.memb
tmp.mc
tmp.nc
2*(tmp.mc - (tmp.nc-1))/(edges.num*(tmp.nc-2)*(tmp.nc-1))
edges.num
## loop over each height and then the groups#
dens.vec    <- vector(, length=hgts.num)#
#
for (i in 1:hgts.num) {#
    groups.uniq <- unique(tmp.mat[,i])#
    groups.num  <- length(groups.uniq)#
#
    tmp.dens <- 0#
    for (j in 1:groups.num) {#
        tmp.idx     <- which(tmp.mat[,i] == groups.uniq[j])#
        tmp.memb    <- union(get.edgelist(lm.igraph)[tmp.idx,1], get.edgelist(lm.igraph)[tmp.idx,2])#
        tmp.mc      <- length(tmp.idx)#
        tmp.nc      <- length(tmp.memb)#
        if (tmp.nc > 2) {#
            tmp.dens    <- tmp.dens + 2*(tmp.mc - (tmp.nc-1))/(edges.num*(tmp.nc-2)*(tmp.nc-1))#
        }#
    }#
    dens.vec[i] <- tmp.dens#
    ## NEXT STEP IS TO REVIEW THE DENSITY FORMULA WITH A CLEAR HEAD#
}
dens.vec
plot(dens.vec)
plot(dens.vec, type="b")
## loop over each height and then the groups#
dens.vec    <- vector(, length=hgts.num)#
#
for (i in 1:hgts.num) {#
    groups.uniq <- unique(tmp.mat[,i])#
    groups.num  <- length(groups.uniq)#
#
    tmp.dens <- 0#
    for (j in 1:groups.num) {#
        tmp.idx     <- which(tmp.mat[,i] == groups.uniq[j])#
        tmp.memb    <- union(get.edgelist(lm.igraph)[tmp.idx,1], get.edgelist(lm.igraph)[tmp.idx,2])#
        tmp.mc      <- length(tmp.idx)#
        tmp.nc      <- length(tmp.memb)#
        if (tmp.nc > 2) {#
            tmp.dens    <- tmp.dens + 2*tmp.mc*(tmp.mc - (tmp.nc-1))/(edges.num*(tmp.nc-2)*(tmp.nc-1))#
        }#
    }#
    dens.vec[i] <- tmp.dens#
    ## NEXT STEP IS TO REVIEW THE DENSITY FORMULA WITH A CLEAR HEAD#
}
tmp.dens
dens.vec
plot(tmp.vec)
plot(dens.vec)
i
max(dens.vec)
edges.num
lm.lc$pdens
## loop over each height and then the groups#
dens.vec    <- vector(, length=hgts.num)#
for (i in 1:hgts.num) {#
    groups.uniq <- unique(tmp.mat[,i])#
    groups.num  <- length(groups.uniq)#
#
    tmp.dens <- 0#
    for (j in 1:groups.num) {#
        tmp.idx     <- which(tmp.mat[,i] == groups.uniq[j])#
        tmp.memb    <- union(get.edgelist(lm.igraph)[tmp.idx,1], get.edgelist(lm.igraph)[tmp.idx,2])#
        tmp.mc      <- length(tmp.idx)#
        tmp.nc      <- length(tmp.memb)#
        if (tmp.nc > 2) {#
            tmp.dens    <- tmp.dens + 2*tmp.mc*(tmp.mc - (tmp.nc-1))/(edges.num*(tmp.nc-2)*(tmp.nc-1))#
        }#
    }#
    dens.vec[i] <- c(0, tmp.dens)#
    ## NEXT STEP IS TO REVIEW THE DENSITY FORMULA WITH A CLEAR HEAD#
}
## loop over each height and then the groups#
dens.vec    <- vector(, length=hgts.num)#
for (i in 1:hgts.num) {#
    groups.uniq <- unique(tmp.mat[,i])#
    groups.num  <- length(groups.uniq)#
#
    tmp.dens <- 0#
    for (j in 1:groups.num) {#
        tmp.idx     <- which(tmp.mat[,i] == groups.uniq[j])#
        tmp.memb    <- union(get.edgelist(lm.igraph)[tmp.idx,1], get.edgelist(lm.igraph)[tmp.idx,2])#
        tmp.mc      <- length(tmp.idx)#
        tmp.nc      <- length(tmp.memb)#
        if (tmp.nc > 2) {#
            tmp.dens    <- tmp.dens + 2*tmp.mc*(tmp.mc - (tmp.nc-1))/(edges.num*(tmp.nc-2)*(tmp.nc-1))#
        }#
    }#
    dens.vec[i] <- tmp.dens#
    ## NEXT STEP IS TO REVIEW THE DENSITY FORMULA WITH A CLEAR HEAD#
}
length(dens.vec)
hgts
length(hgts)
cbind(hgts, dens.vec)
lm.lc$pdens
cbind(hgts, dens.vec, lm.lc$pdens)
hgts
cbind(hgts, dens.vec, lm.lc$pdens[-1,])
calcPartitionDensity    <- function(myHclust, myIgraph)#
{#
    h.vec   <- unique(myHclust$height)#
    h.num   <- length(h)#
    e.num   <- nrow(get.edgelist(myIgraph))#
    ## matrix to hold the identify of group members at each height#
    clust.mat   <- matrix(0, nrow=e.num, ncol=h.num)#
    dens.vec    <- vector(, length=h.num)#
#
    ## loop each height and compute the partition density#
    for (i in 1:h.num) {#
        tmp.mat[,i]   <- as.vector(cutree(lm.clust, h=hgts[i]))#
        groups.uniq   <- unique(tmp.mat[,i])#
        groups.num    <- length(groups.uniq)#
        tmp.dens      <- 0#
        ## loop over all groups at a height and compute the density#
        for (j in 1:groups.num) {#
           ## identify location of the group memebers#
           tmp.idx     <- which(tmp.mat[,i] == groups.uniq[j])#
           tmp.memb    <- union(get.edgelist(lm.igraph)[tmp.idx,1], get.edgelist(lm.igraph)[tmp.idx,2])#
           ## compute the number of nodes and edges in the group#
           tmp.mc      <- length(tmp.idx)#
           tmp.nc      <- length(tmp.memb)#
           ## by convention, clusers with two nodes has a density of 0#
           if (tmp.nc > 2) {#
               tmp.dens    <- tmp.dens + 2*tmp.mc*(tmp.mc - (tmp.nc-1))/(e.num*(tmp.nc-2)*(tmp.nc-1))#
           }#
        }#
        dens.vec[i] <- tmp.dens#
#
    }#
    return(data.frame(h=h.vec, den=dens.vec))#
}
lm.clust
lm.igraph
a <- calcPartitionDensity(lm.clust, lm.igraph)
calcPartitionDensity    <- function(myHclust, myIgraph)#
{#
    h.vec   <- unique(myHclust$height)#
    h.num   <- length(h.vec)#
    e.num   <- nrow(get.edgelist(myIgraph))#
    ## matrix to hold the identify of group members at each height#
    clust.mat   <- matrix(0, nrow=e.num, ncol=h.num)#
    dens.vec    <- vector(, length=h.num)#
#
    ## loop each height and compute the partition density#
    for (i in 1:h.num) {#
        tmp.mat[,i]   <- as.vector(cutree(lm.clust, h=hgts[i]))#
        groups.uniq   <- unique(tmp.mat[,i])#
        groups.num    <- length(groups.uniq)#
        tmp.dens      <- 0#
        ## loop over all groups at a height and compute the density#
        for (j in 1:groups.num) {#
           ## identify location of the group memebers#
           tmp.idx     <- which(tmp.mat[,i] == groups.uniq[j])#
           tmp.memb    <- union(get.edgelist(lm.igraph)[tmp.idx,1], get.edgelist(lm.igraph)[tmp.idx,2])#
           ## compute the number of nodes and edges in the group#
           tmp.mc      <- length(tmp.idx)#
           tmp.nc      <- length(tmp.memb)#
           ## by convention, clusers with two nodes has a density of 0#
           if (tmp.nc > 2) {#
               tmp.dens    <- tmp.dens + 2*tmp.mc*(tmp.mc - (tmp.nc-1))/(e.num*(tmp.nc-2)*(tmp.nc-1))#
           }#
        }#
        dens.vec[i] <- tmp.dens#
#
    }#
    return(data.frame(h=h.vec, den=dens.vec))#
}
a <- calcPartitionDensity(lm.clust, lm.igraph)
head(a)
plot(h)
plot(a$h, a$den)
plot(a$h, a$den, type="b")
calcPartitionDensity    <- function(myHclust, myIgraph)#
{#
    h.vec   <- unique(myHclust$height)#
    h.num   <- length(h.vec)#
    e.num   <- nrow(get.edgelist(myIgraph))#
    ## matrix to hold the identify of group members at each height#
    #clust.mat   <- matrix(0, nrow=e.num, ncol=h.num)#
    dens.vec    <- vector(, length=h.num)#
#
    ## loop each height and compute the partition density#
    for (i in 1:h.num) {#
      #tmp.mat[,i]   <- as.vector(cutree(lm.clust, h=hgts[i]))#
      #groups.uniq   <- unique(tmp.mat[,i])#
       group.uniq   <- as.vector(cutree(lm.clust, h=hgts[i]))#
        groups.num    <- length(groups.uniq)#
        tmp.dens      <- 0#
        ## loop over all groups at a height and compute the density#
        for (j in 1:groups.num) {#
           ## identify location of the group memebers#
           tmp.idx     <- which(tmp.mat[,i] == groups.uniq[j])#
           tmp.memb    <- union(get.edgelist(lm.igraph)[tmp.idx,1], get.edgelist(lm.igraph)[tmp.idx,2])#
           ## compute the number of nodes and edges in the group#
           tmp.mc      <- length(tmp.idx)#
           tmp.nc      <- length(tmp.memb)#
           ## by convention, clusers with two nodes has a density of 0#
           if (tmp.nc > 2) {#
               tmp.dens    <- tmp.dens + 2*tmp.mc*(tmp.mc - (tmp.nc-1))/(e.num*(tmp.nc-2)*(tmp.nc-1))#
           }#
        }#
        dens.vec[i] <- tmp.dens#
#
    }#
    return(data.frame(h=h.vec, den=dens.vec))#
}
a <- calcPartitionDensity(lm.clust, lm.igraph)
a
calcPartitionDensity    <- function(myHclust, myIgraph)#
{#
    h.vec   <- unique(myHclust$height)#
    h.num   <- length(h.vec)#
    e.num   <- nrow(get.edgelist(myIgraph))#
    ## matrix to hold the identify of group members at each height#
    clust.vec   <- matrix(, length=h.num)#
    dens.vec    <- vector(, length=h.num)#
#
    ## loop each height and compute the partition density#
    for (i in 1:h.num) {#
      #tmp.mat[,i]   <- as.vector(cutree(lm.clust, h=hgts[i]))#
      #groups.uniq   <- unique(tmp.mat[,i])#
      clust.vec <- as.vector(cutree(lm.clust, h=hgts[i]))#
      groups.uniq   <- unique(clust.vec)#
        groups.num    <- length(groups.uniq)#
        tmp.dens      <- 0#
        ## loop over all groups at a height and compute the density#
        for (j in 1:groups.num) {#
           ## identify location of the group memebers#
           tmp.idx     <- which(clust.vec == groups.uniq[j])#
           tmp.memb    <- union(get.edgelist(lm.igraph)[tmp.idx,1], get.edgelist(lm.igraph)[tmp.idx,2])#
           ## compute the number of nodes and edges in the group#
           tmp.mc      <- length(tmp.idx)#
           tmp.nc      <- length(tmp.memb)#
           ## by convention, clusers with two nodes has a density of 0#
           if (tmp.nc > 2) {#
               tmp.dens    <- tmp.dens + 2*tmp.mc*(tmp.mc - (tmp.nc-1))/(e.num*(tmp.nc-2)*(tmp.nc-1))#
           }#
        }#
        dens.vec[i] <- tmp.dens#
#
    }#
    return(data.frame(h=h.vec, den=dens.vec))#
}
a <- calcPartitionDensity(lm.clust, lm.igraph)
calcPartitionDensity    <- function(myHclust, myIgraph)#
{#
    h.vec   <- unique(myHclust$height)#
    h.num   <- length(h.vec)#
    e.num   <- nrow(get.edgelist(myIgraph))#
    ## matrix to hold the identify of group members at each height#
    clust.vec   <- vector(, length=h.num)#
    dens.vec    <- vector(, length=h.num)#
#
    ## loop each height and compute the partition density#
    for (i in 1:h.num) {#
      #tmp.mat[,i]   <- as.vector(cutree(lm.clust, h=hgts[i]))#
      #groups.uniq   <- unique(tmp.mat[,i])#
      clust.vec <- as.vector(cutree(lm.clust, h=hgts[i]))#
      groups.uniq   <- unique(clust.vec)#
        groups.num    <- length(groups.uniq)#
        tmp.dens      <- 0#
        ## loop over all groups at a height and compute the density#
        for (j in 1:groups.num) {#
           ## identify location of the group memebers#
           tmp.idx     <- which(clust.vec == groups.uniq[j])#
           tmp.memb    <- union(get.edgelist(lm.igraph)[tmp.idx,1], get.edgelist(lm.igraph)[tmp.idx,2])#
           ## compute the number of nodes and edges in the group#
           tmp.mc      <- length(tmp.idx)#
           tmp.nc      <- length(tmp.memb)#
           ## by convention, clusers with two nodes has a density of 0#
           if (tmp.nc > 2) {#
               tmp.dens    <- tmp.dens + 2*tmp.mc*(tmp.mc - (tmp.nc-1))/(e.num*(tmp.nc-2)*(tmp.nc-1))#
           }#
        }#
        dens.vec[i] <- tmp.dens#
#
    }#
    return(data.frame(h=h.vec, den=dens.vec))#
}
a <- calcPartitionDensity(lm.clust, lm.igraph)
a
plot(a$h, a$den, type="b")
##------------------------------------------------------------------#
## Clear the workspace#
##------------------------------------------------------------------#
rm(list=ls())#
#
##------------------------------------------------------------------#
## Load utility functions#
##------------------------------------------------------------------#
source("/Users/alexstephens/Development/kaggle/social_circle/k_soc/00_Utilities.r")#
##------------------------------------------------------------------#
## Benchmark: Les Miserables characters connected graph#
##------------------------------------------------------------------#
#
## load the raw dataset (from linkcomm())#
lm <- lesmiserables#
#
##------------------------------------------------------------------#
## Step 1:  This is somewhat redundant, but translate the Les Mis#
## factor/edge list into the egonet structure that I've loaded#
## from the kaggle competition.#
##------------------------------------------------------------------#
#
## convert the data of factors into characters#
tmp.lm <- convert.magic(lm, c("V1","V2"), c("character","character"))#
#
## map character names to integers#
nodes_l.uniq    <- unique(tmp.lm$V1)#
nodes_r.uniq    <- unique(tmp.lm$V2)#
characters.uniq <- union(nodes_l.uniq, nodes_r.uniq)#
characters.ids  <- 1:length(characters.uniq)#
#
## define the egonet#
lm.egonet  <- list()#
#
## load the egonet#
for (i in 1:length(nodes_l.uniq)) {#
    ## get a vertex & assign an id#
    tmp.node    <- nodes_l.uniq[i]#
    tmp.id      <- characters.ids[ which(characters.uniq == tmp.node)]#
    char.id     <- paste("ID_",tmp.id,sep="")#
    ## get the list of characters (and their ids) associated with this vertex#
    lm.egonet[[char.id]] <- paste("ID_", characters.ids[ which(characters.uniq %in% tmp.lm$V2[which(tmp.lm$V1 == tmp.node)]) ], sep="")#
}#
#
##------------------------------------------------------------------#
## Step 2:  At this point, the Les Mis data are in a format that#
## is similar to the loaded kaggle data format. Load the raw data#
## into an igraph object#
##------------------------------------------------------------------#
lm.igraph   <- convEgonetListToIgraphObject(lm.egonet)#
##------------------------------------------------------------------#
## Step 3:  Compute the dissimilarity measure amongst the clusters.#
## The similarity measure is the Jaccard coefficient. The Jaccard#
## *distance* is 1 minus the Jaccard coefficient.#
##------------------------------------------------------------------#
#
lm.sim      <- calcSimilarityMatrix(lm.igraph)  ## similarity matrix#
lm.dis      <- 1 - lm.sim                       ## jaccard distance#
#
##------------------------------------------------------------------#
## Step 3:  Compute the cluster#
##------------------------------------------------------------------#
#
## create a distance object from the dissimilarity matrix#
lm.dist     <- as.dist(lm.dis)#
#
## compute a cluster#
lm.clust    <- hclust(lm.dist, method="single")#
lm.dend     <- as.dendrogram(lm.clust)#
##------------------------------------------------------------------#
## Step 4:  Verify cluster output using linkcomm() [ok]#
##------------------------------------------------------------------
calcPartitionDensity    <- function(myHclust, myIgraph)#
{#
    h.vec       <- unique(myHclust$height)#
    h.num       <- length(h.vec)#
    e.num       <- nrow(get.edgelist(myIgraph))#
    ## matrix to hold the identify of group members at each height#
    clust.vec   <- vector(, length=h.num)#
    dens.vec    <- vector(, length=h.num)#
#
    ## loop each height and compute the partition density#
    for (i in 1:h.num) {#
        clust.vec     <- as.vector(cutree(lm.clust, h=h.vec[i]))#
        groups.uniq   <- unique(clust.vec)#
        groups.num    <- length(groups.uniq)#
        tmp.dens      <- 0#
        ## loop over all groups at a height and compute the density#
        for (j in 1:groups.num) {#
           ## identify location of the group memebers#
           tmp.idx     <- which(clust.vec == groups.uniq[j])#
           tmp.memb    <- union(get.edgelist(lm.igraph)[tmp.idx,1], get.edgelist(lm.igraph)[tmp.idx,2])#
           ## compute the number of nodes and edges in the group#
           tmp.mc      <- length(tmp.idx)#
           tmp.nc      <- length(tmp.memb)#
           ## by convention, clusers with two nodes has a density of 0#
           if (tmp.nc > 2) {#
               tmp.dens    <- tmp.dens + 2*tmp.mc*(tmp.mc - (tmp.nc-1))/(e.num*(tmp.nc-2)*(tmp.nc-1))#
           }#
        }#
        dens.vec[i] <- tmp.dens#
#
    }#
    return(data.frame(h=h.vec, den=dens.vec))#
}
a <- calcPartitionDensity(lm.clust, lm.igraph)
a
plot(a$h, a$den)
##------------------------------------------------------------------#
## The purpose of this script is to re-create an example set of#
## clusters.  The example (the Les Miserables characters) set of#
## edges is taken from Ahn, and there is an R package that will#
## reproduce that results (linkcomm()).  I want to reproduce it#
## as well because I will be modifying the basic result (i.e.,#
## a similarity matrix to reproduce the Ye [?] et al. paper.#
##------------------------------------------------------------------#
#
##------------------------------------------------------------------#
## Load libraries#
##------------------------------------------------------------------#
library(igraph)                 ## contains graph functions#
library(linkcomm)               ## contains link community functions#
library(dendextend)             ## contains dendrogram functions#
library(caTools)#
librart(gdata)#
#
##------------------------------------------------------------------#
## Clear the workspace#
##------------------------------------------------------------------#
rm(list=ls())#
#
##------------------------------------------------------------------#
## Load utility functions#
##------------------------------------------------------------------#
source("/Users/alexstephens/Development/kaggle/social_circle/k_soc/00_Utilities.r")#
##------------------------------------------------------------------#
## Benchmark: Les Miserables characters connected graph#
##------------------------------------------------------------------#
#
## load the raw dataset (from linkcomm())#
lm <- lesmiserables#
#
##------------------------------------------------------------------#
## Step 1:  This is somewhat redundant, but translate the Les Mis#
## factor/edge list into the egonet structure that I've loaded#
## from the kaggle competition.#
##------------------------------------------------------------------#
#
## convert the data of factors into characters#
tmp.lm <- convert.magic(lm, c("V1","V2"), c("character","character"))#
#
## map character names to integers#
nodes_l.uniq    <- unique(tmp.lm$V1)#
nodes_r.uniq    <- unique(tmp.lm$V2)#
characters.uniq <- union(nodes_l.uniq, nodes_r.uniq)#
characters.ids  <- 1:length(characters.uniq)#
#
## define the egonet#
lm.egonet  <- list()#
#
## load the egonet#
for (i in 1:length(nodes_l.uniq)) {#
    ## get a vertex & assign an id#
    tmp.node    <- nodes_l.uniq[i]#
    tmp.id      <- characters.ids[ which(characters.uniq == tmp.node)]#
    char.id     <- paste("ID_",tmp.id,sep="")#
    ## get the list of characters (and their ids) associated with this vertex#
    lm.egonet[[char.id]] <- paste("ID_", characters.ids[ which(characters.uniq %in% tmp.lm$V2[which(tmp.lm$V1 == tmp.node)]) ], sep="")#
}#
#
##------------------------------------------------------------------#
## Step 2:  At this point, the Les Mis data are in a format that#
## is similar to the loaded kaggle data format. Load the raw data#
## into an igraph object#
##------------------------------------------------------------------#
lm.igraph   <- convEgonetListToIgraphObject(lm.egonet)#
##------------------------------------------------------------------#
## Step 3:  Compute the dissimilarity measure amongst the clusters.#
## The similarity measure is the Jaccard coefficient. The Jaccard#
## *distance* is 1 minus the Jaccard coefficient.#
##------------------------------------------------------------------#
#
lm.sim      <- calcSimilarityMatrix(lm.igraph)  ## similarity matrix#
lm.dis      <- 1 - lm.sim                       ## jaccard distance#
#
##------------------------------------------------------------------#
## Step 3:  Compute the cluster#
##------------------------------------------------------------------#
#
## create a distance object from the dissimilarity matrix#
lm.dist     <- as.dist(lm.dis)#
#
## compute a cluster#
lm.clust    <- hclust(lm.dist, method="single")#
lm.dend     <- as.dendrogram(lm.clust)#
##------------------------------------------------------------------#
## Step 4:  Verify cluster output using linkcomm() [ok]#
##------------------------------------------------------------------#
#
## use linkcomm() to compute the cluster#
lm.lc       <- getLinkCommunities(get.data.frame(lm.igraph,"edges"), hcmethod="single")#
comp.clust  <- cbind(lm.lc$hclust$height, lm.clust$height, lm.lc$hclust$height-lm.clust$height)
lm.lc$clusters
lapply(lm.lc$clusters, length)
sum(unlist(lapply(lm.lc$clusters, length)))
calcPartitionDensity    <- function(myHclust, myIgraph)#
{#
    h.vec       <- unique(myHclust$height)#
    h.num       <- length(h.vec)#
    e.num       <- nrow(get.edgelist(myIgraph))#
    ## matrix to hold the identify of group members at each height#
    clust.vec   <- vector(, length=h.num)#
    dens.vec    <- vector(, length=h.num)#
    ## loop each height and compute the partition density#
    for (i in 1:h.num) {#
        clust.vec     <- as.vector(cutree(myHclust, h=h.vec[i]))#
        groups.uniq   <- unique(clust.vec)#
        groups.num    <- length(groups.uniq)#
        tmp.dens      <- 0#
        ## loop over all groups at a height and compute the density#
        for (j in 1:groups.num) {#
            ## identify location of the group memebers#
            tmp.idx     <- which(clust.vec == groups.uniq[j])#
            tmp.memb    <- union(get.edgelist(myIgraph)[tmp.idx,1], get.edgelist(myIgraph)[tmp.idx,2])#
            ## compute the number of nodes and edges in the group#
            tmp.mc      <- length(tmp.idx)#
            tmp.nc      <- length(tmp.memb)#
            ## by convention, clusers with two nodes has a density of 0#
            if (tmp.nc > 2) {#
                tmp.dens    <- tmp.dens + 2*tmp.mc*(tmp.mc - (tmp.nc-1))/(e.num*(tmp.nc-2)*(tmp.nc-1))#
            }#
        }#
        dens.vec[i] <- tmp.dens#
    }#
    ## accumulate results#
    pdens   <- data.frame(h=h.vec, den=dens.vec)#
    pdmax   <- max(dens.vec)#
    hmax    <- h.vec[dens.vec == pdmax]#
    cmax    <- cutree(myHclust, h=h.vec[i])#
    return(list(pdens, pdmax, hmax, cmax))#
}
lm.dens <- calcParitionDensity(lm.clust, lm.igraph)
lm.dens <- calcPartitionDensity(lm.clust, lm.igraph)
lm.dens
calcPartitionDensity    <- function(myHclust, myIgraph)#
{#
    h.vec       <- unique(myHclust$height)#
    h.num       <- length(h.vec)#
    e.num       <- nrow(get.edgelist(myIgraph))#
    ## matrix to hold the identify of group members at each height#
    clust.vec   <- vector(, length=h.num)#
    dens.vec    <- vector(, length=h.num)#
    ## loop each height and compute the partition density#
    for (i in 1:h.num) {#
        clust.vec     <- as.vector(cutree(myHclust, h=h.vec[i]))#
        groups.uniq   <- unique(clust.vec)#
        groups.num    <- length(groups.uniq)#
        tmp.dens      <- 0#
        ## loop over all groups at a height and compute the density#
        for (j in 1:groups.num) {#
            ## identify location of the group memebers#
            tmp.idx     <- which(clust.vec == groups.uniq[j])#
            tmp.memb    <- union(get.edgelist(myIgraph)[tmp.idx,1], get.edgelist(myIgraph)[tmp.idx,2])#
            ## compute the number of nodes and edges in the group#
            tmp.mc      <- length(tmp.idx)#
            tmp.nc      <- length(tmp.memb)#
            ## by convention, clusers with two nodes has a density of 0#
            if (tmp.nc > 2) {#
                tmp.dens    <- tmp.dens + 2*tmp.mc*(tmp.mc - (tmp.nc-1))/(e.num*(tmp.nc-2)*(tmp.nc-1))#
            }#
        }#
        dens.vec[i] <- tmp.dens#
    }#
    ## accumulate results#
    pdens   <- data.frame(h=h.vec, den=dens.vec)#
    pdmax   <- max(dens.vec)#
    hmax    <- h.vec[dens.vec == pdmax]#
    cmax    <- cutree(myHclust, h=hmax)#
    return(list(pdens, pdmax, hmax, cmax))#
}
lm.dens <- calcPartitionDensity(lm.clust, lm.igraph)
lm.dens
table(lm.dens[[4]])
calcPartitionDensity    <- function(myHclust, myIgraph)#
{#
    h.vec       <- unique(myHclust$height)#
    h.num       <- length(h.vec)#
    e.num       <- nrow(get.edgelist(myIgraph))#
    ## matrix to hold the identify of group members at each height#
    clust.vec   <- vector(, length=h.num)#
    dens.vec    <- vector(, length=h.num)#
    ## loop each height and compute the partition density#
    for (i in 1:h.num) {#
        clust.vec     <- as.vector(cutree(myHclust, h=h.vec[i]))#
        groups.uniq   <- unique(clust.vec)#
        groups.num    <- length(groups.uniq)#
        tmp.dens      <- 0#
        ## loop over all groups at a height and compute the density#
        for (j in 1:groups.num) {#
            ## identify location of the group memebers#
            tmp.idx     <- which(clust.vec == groups.uniq[j])#
            tmp.memb    <- union(get.edgelist(myIgraph)[tmp.idx,1], get.edgelist(myIgraph)[tmp.idx,2])#
            ## compute the number of nodes and edges in the group#
            tmp.mc      <- length(tmp.idx)#
            tmp.nc      <- length(tmp.memb)#
            ## by convention, clusers with two nodes has a density of 0#
            if (tmp.nc > 2) {#
                tmp.dens    <- tmp.dens + 2*tmp.mc*(tmp.mc - (tmp.nc-1))/(e.num*(tmp.nc-2)*(tmp.nc-1))#
            }#
        }#
        dens.vec[i] <- tmp.dens#
    }#
    ## accumulate results#
    pdens   <- data.frame(h=h.vec, den=dens.vec)#
    pdmax   <- max(dens.vec)#
    hmax    <- h.vec[dens.vec == pdmax]#
    cmax    <- cutree(myHclust, h=hmax)#
    return(list(pdens=pdens, pdmax=pdmax, hmax=hmax, clust.ids=cmax))#
}#
calcPartitionDensity    <- function(myHclust, myIgraph)#
{#
    h.vec       <- unique(myHclust$height)#
    h.num       <- length(h.vec)#
    e.num       <- nrow(get.edgelist(myIgraph))#
    ## matrix to hold the identify of group members at each height#
    clust.vec   <- vector(, length=h.num)#
    dens.vec    <- vector(, length=h.num)#
    ## loop each height and compute the partition density#
    for (i in 1:h.num) {#
        clust.vec     <- as.vector(cutree(myHclust, h=h.vec[i]))#
        groups.uniq   <- unique(clust.vec)#
        groups.num    <- length(groups.uniq)#
        tmp.dens      <- 0#
        ## loop over all groups at a height and compute the density#
        for (j in 1:groups.num) {#
            ## identify location of the group memebers#
            tmp.idx     <- which(clust.vec == groups.uniq[j])#
            tmp.memb    <- union(get.edgelist(myIgraph)[tmp.idx,1], get.edgelist(myIgraph)[tmp.idx,2])#
            ## compute the number of nodes and edges in the group#
            tmp.mc      <- length(tmp.idx)#
            tmp.nc      <- length(tmp.memb)#
            ## by convention, clusers with two nodes has a density of 0#
            if (tmp.nc > 2) {#
                tmp.dens    <- tmp.dens + 2*tmp.mc*(tmp.mc - (tmp.nc-1))/(e.num*(tmp.nc-2)*(tmp.nc-1))#
            }#
        }#
        dens.vec[i] <- tmp.dens#
    }#
    ## accumulate results#
    pdens   <- data.frame(h=h.vec, den=dens.vec)#
    pdmax   <- max(dens.vec)#
    hmax    <- h.vec[dens.vec == pdmax]#
    cmax    <- cutree(myHclust, h=hmax)#
    return(list(pdens=pdens, pdmax=pdmax, hmax=hmax, clust.ids=cmax))#
}
calcPartitionDensity    <- function(myHclust, myIgraph)#
{#
    h.vec       <- unique(myHclust$height)#
    h.num       <- length(h.vec)#
    e.num       <- nrow(get.edgelist(myIgraph))#
    ## matrix to hold the identify of group members at each height#
    clust.vec   <- vector(, length=h.num)#
    dens.vec    <- vector(, length=h.num)#
    ## loop each height and compute the partition density#
    for (i in 1:h.num) {#
        clust.vec     <- as.vector(cutree(myHclust, h=h.vec[i]))#
        groups.uniq   <- unique(clust.vec)#
        groups.num    <- length(groups.uniq)#
        tmp.dens      <- 0#
        ## loop over all groups at a height and compute the density#
        for (j in 1:groups.num) {#
            ## identify location of the group memebers#
            tmp.idx     <- which(clust.vec == groups.uniq[j])#
            tmp.memb    <- union(get.edgelist(myIgraph)[tmp.idx,1], get.edgelist(myIgraph)[tmp.idx,2])#
            ## compute the number of nodes and edges in the group#
            tmp.mc      <- length(tmp.idx)#
            tmp.nc      <- length(tmp.memb)#
            ## by convention, clusers with two nodes has a density of 0#
            if (tmp.nc > 2) {#
                tmp.dens    <- tmp.dens + 2*tmp.mc*(tmp.mc - (tmp.nc-1))/(e.num*(tmp.nc-2)*(tmp.nc-1))#
            }#
        }#
        dens.vec[i] <- tmp.dens#
    }#
    ## accumulate results#
    pdens   <- data.frame(h=h.vec, den=dens.vec)#
    pdmax   <- max(dens.vec)#
    hmax    <- h.vec[dens.vec == pdmax]#
    cmax    <- cutree(myHclust, h=hmax)#
    return(list(pdens=pdens, pdmax=pdmax, hmax=hmax, clust.ids=cmax))#
}
table(lm.dens[[4]])
lm.dens <- calcPartitionDensity(lm.clust, lm.igraph)
lm.dens
lm.dens$clust.ids
table(lm.dens$clust.ids)
a <- table(lm.dens$clust.ids)
a[a>1]
length(a[a>1])
lm.lc$clusters
lm.dens$clust.ids
length(unique(lm.dens$clust.ids))
edges(get.edgelist(lm.igraph))
edges(lm.igraph)
lm.clust
lm.dens
as.vector(lm.dens$clust.ids)
as.vector(lm.dens$clust.ids) == lm.dens$clust.ids[2]
calcPartitionDensity    <- function(myHclust, myIgraph)#
{#
    h.vec       <- unique(myHclust$height)#
    h.num       <- length(h.vec)#
    e.num       <- nrow(get.edgelist(myIgraph))#
    e.idx       <- 1:e.num#
    ## matrix to hold the identify of group members at each height#
    clust.vec   <- vector(, length=h.num)#
    dens.vec    <- vector(, length=h.num)#
    ## loop each height and compute the partition density#
    for (i in 1:h.num) {#
        clust.vec     <- as.vector(cutree(myHclust, h=h.vec[i]))#
        groups.uniq   <- unique(clust.vec)#
        groups.num    <- length(groups.uniq)#
        tmp.dens      <- 0#
        ## loop over all groups at a height and compute the density#
        for (j in 1:groups.num) {#
            ## identify location of the group memebers#
            tmp.idx     <- which(clust.vec == groups.uniq[j])#
            tmp.memb    <- union(get.edgelist(myIgraph)[tmp.idx,1], get.edgelist(myIgraph)[tmp.idx,2])#
            ## compute the number of nodes and edges in the group#
            tmp.mc      <- length(tmp.idx)#
            tmp.nc      <- length(tmp.memb)#
            ## by convention, clusers with two nodes has a density of 0#
            if (tmp.nc > 2) {#
                tmp.dens    <- tmp.dens + 2*tmp.mc*(tmp.mc - (tmp.nc-1))/(e.num*(tmp.nc-2)*(tmp.nc-1))#
            }#
        }#
        dens.vec[i] <- tmp.dens#
    }#
    ## idenitfy the maximum density & corresponding height#
    pdens   <- data.frame(h=h.vec, den=dens.vec)#
    pdmax   <- max(dens.vec)#
    hmax    <- h.vec[dens.vec == pdmax]#
    ## isolate cluster memebers#
    clust.ids   <- cutree(myHclust, h=hmax)#
    clust.num   <- length(unique(clust.ids))#
    clust.list  <- list()#
    clust.cnt   <- 1#
    for (i in 1:clust.num) {#
        tmp.clust   <- clust.ids[i]#
        tmp.idx     <- which(as.vector(lm.dens$clust.ids) == tmp.clust)#
        tmp.memb    <- union(get.edgelist(myIgraph)[tmp.idx,1], get.edgelist(myIgraph)[tmp.idx,2])#
        if (length(tmp.memb) >= 3) {#
            clust.list[[clust.cnt]] <- tmp.memb#
            clust.cnt   <- clust.cnt + 1#
        }#
    }#
    return(list(pdens=pdens, pdmax=pdmax, hmax=hmax, clust.ids=cmax, clust.list=clust.list))#
}
a <- calcPartitionDensity(lm.clust, lm.igraph)
calcPartitionDensity    <- function(myHclust, myIgraph)#
{#
    h.vec       <- unique(myHclust$height)#
    h.num       <- length(h.vec)#
    e.num       <- nrow(get.edgelist(myIgraph))#
    e.idx       <- 1:e.num#
    ## matrix to hold the identify of group members at each height#
    clust.vec   <- vector(, length=h.num)#
    dens.vec    <- vector(, length=h.num)#
    ## loop each height and compute the partition density#
    for (i in 1:h.num) {#
        clust.vec     <- as.vector(cutree(myHclust, h=h.vec[i]))#
        groups.uniq   <- unique(clust.vec)#
        groups.num    <- length(groups.uniq)#
        tmp.dens      <- 0#
        ## loop over all groups at a height and compute the density#
        for (j in 1:groups.num) {#
            ## identify location of the group memebers#
            tmp.idx     <- which(clust.vec == groups.uniq[j])#
            tmp.memb    <- union(get.edgelist(myIgraph)[tmp.idx,1], get.edgelist(myIgraph)[tmp.idx,2])#
            ## compute the number of nodes and edges in the group#
            tmp.mc      <- length(tmp.idx)#
            tmp.nc      <- length(tmp.memb)#
            ## by convention, clusers with two nodes has a density of 0#
            if (tmp.nc > 2) {#
                tmp.dens    <- tmp.dens + 2*tmp.mc*(tmp.mc - (tmp.nc-1))/(e.num*(tmp.nc-2)*(tmp.nc-1))#
            }#
        }#
        dens.vec[i] <- tmp.dens#
    }#
    ## idenitfy the maximum density & corresponding height#
    pdens   <- data.frame(h=h.vec, den=dens.vec)#
    pdmax   <- max(dens.vec)#
    hmax    <- h.vec[dens.vec == pdmax]#
    ## isolate cluster memebers#
    clust.ids   <- cutree(myHclust, h=hmax)#
    clust.num   <- length(unique(clust.ids))#
    clust.list  <- list()#
    clust.cnt   <- 1#
    for (i in 1:clust.num) {#
        tmp.clust   <- clust.ids[i]#
        tmp.idx     <- which(as.vector(lm.dens$clust.ids) == tmp.clust)#
        tmp.memb    <- union(get.edgelist(myIgraph)[tmp.idx,1], get.edgelist(myIgraph)[tmp.idx,2])#
        if (length(tmp.memb) >= 3) {#
            clust.list[[clust.cnt]] <- tmp.memb#
            clust.cnt   <- clust.cnt + 1#
        }#
    }#
    return(list(pdens=pdens, pdmax=pdmax, hmax=hmax, clust.ids=clust.ids, clust.list=clust.list))#
}
a <- calcPartitionDensity(lm.clust, lm.igraph)
a
clust.ids <- cutree(lm.clust, h= 0.6363636)
clust.ids
calcPartitionDensity    <- function(myHclust, myIgraph)#
{#
    h.vec       <- unique(myHclust$height)#
    h.num       <- length(h.vec)#
    e.num       <- nrow(get.edgelist(myIgraph))#
    e.idx       <- 1:e.num#
    ## matrix to hold the identify of group members at each height#
    clust.vec   <- vector(, length=h.num)#
    dens.vec    <- vector(, length=h.num)#
    ## loop each height and compute the partition density#
    for (i in 1:h.num) {#
        clust.vec     <- as.vector(cutree(myHclust, h=h.vec[i]))#
        groups.uniq   <- unique(clust.vec)#
        groups.num    <- length(groups.uniq)#
        tmp.dens      <- 0#
        ## loop over all groups at a height and compute the density#
        for (j in 1:groups.num) {#
            ## identify location of the group memebers#
            tmp.idx     <- which(clust.vec == groups.uniq[j])#
            tmp.memb    <- union(get.edgelist(myIgraph)[tmp.idx,1], get.edgelist(myIgraph)[tmp.idx,2])#
            ## compute the number of nodes and edges in the group#
            tmp.mc      <- length(tmp.idx)#
            tmp.nc      <- length(tmp.memb)#
            ## by convention, clusers with two nodes has a density of 0#
            if (tmp.nc > 2) {#
                tmp.dens    <- tmp.dens + 2*tmp.mc*(tmp.mc - (tmp.nc-1))/(e.num*(tmp.nc-2)*(tmp.nc-1))#
            }#
        }#
        dens.vec[i] <- tmp.dens#
    }#
    ## idenitfy the maximum density & corresponding height#
    pdens   <- data.frame(h=h.vec, den=dens.vec)#
    pdmax   <- max(dens.vec)#
    hmax    <- h.vec[dens.vec == pdmax]#
    ## isolate cluster memebers#
    clust.ids   <- cutree(myHclust, h=hmax)#
    clust.uniq  <- unique(clust.ids)#
    clust.num   <- length(clust.uniq)#
    clust.list  <- list()#
    clust.cnt   <- 1#
    for (i in 1:clust.num) {#
        tmp.clust   <- clust.uniq[i]#
        tmp.idx     <- which(as.vector(lm.dens$clust.ids) == tmp.clust)#
        tmp.memb    <- union(get.edgelist(myIgraph)[tmp.idx,1], get.edgelist(myIgraph)[tmp.idx,2])#
        if (length(tmp.memb) >= 3) {#
            clust.list[[clust.cnt]] <- tmp.memb#
            clust.cnt   <- clust.cnt + 1#
        }#
    }#
    return(list(pdens=pdens, pdmax=pdmax, hmax=hmax, clust.ids=clust.ids, clust.list=clust.list))#
}
a <- calcPartitionDensity(lm.clust, lm.igraph)
a
lm.lc$clusters
table(clust.ids)
length(    clust.uniq  <- unique(clust.ids)#
    clust.num   <- length(clust.uniq)#
    clust.list  <- list()#
)
clust.uniq  <- unique(clust.ids)#
    clust.num   <- length(clust.uniq)#
    clust.list  <- list()
clust.uniq
clust.num
i <- 49
tmp.clust   <- clust.uniq[i]#
        tmp.idx     <- which(as.vector(lm.dens$clust.ids) == tmp.clust)#
        tmp.memb    <- union(get.edgelist(myIgraph)[tmp.idx,1], get.edgelist(myIgraph)[tmp.idx,2])
myIgraph <- lm.igraph
tmp.clust   <- clust.uniq[i]#
        tmp.idx     <- which(as.vector(lm.dens$clust.ids) == tmp.clust)#
        tmp.memb    <- union(get.edgelist(myIgraph)[tmp.idx,1], get.edgelist(myIgraph)[tmp.idx,2])
tmp.clust
tmp.id
tmp.idx
as.vector(lm.dens$clust.ids)
clust.ids
tmp.idx
a <- 1:254
i
i <- 47
a[which(as.vector(lm.dens$clust.ids) == tmp.clust)]
a[which(as.vector(lm.dens$clust.ids) == 47)]
calcPartitionDensity    <- function(myHclust, myIgraph)#
{#
    h.vec       <- unique(myHclust$height)#
    h.num       <- length(h.vec)#
    e.num       <- nrow(get.edgelist(myIgraph))#
    e.idx       <- 1:e.num#
    ## matrix to hold the identify of group members at each height#
    clust.vec   <- vector(, length=h.num)#
    dens.vec    <- vector(, length=h.num)#
    ## loop each height and compute the partition density#
    for (i in 1:h.num) {#
        clust.vec     <- as.vector(cutree(myHclust, h=h.vec[i]))#
        groups.uniq   <- unique(clust.vec)#
        groups.num    <- length(groups.uniq)#
        tmp.dens      <- 0#
        ## loop over all groups at a height and compute the density#
        for (j in 1:groups.num) {#
            ## identify location of the group memebers#
            tmp.idx     <- which(clust.vec == groups.uniq[j])#
            tmp.memb    <- union(get.edgelist(myIgraph)[tmp.idx,1], get.edgelist(myIgraph)[tmp.idx,2])#
            ## compute the number of nodes and edges in the group#
            tmp.mc      <- length(tmp.idx)#
            tmp.nc      <- length(tmp.memb)#
            ## by convention, clusers with two nodes has a density of 0#
            if (tmp.nc > 2) {#
                tmp.dens    <- tmp.dens + 2*tmp.mc*(tmp.mc - (tmp.nc-1))/(e.num*(tmp.nc-2)*(tmp.nc-1))#
            }#
        }#
        dens.vec[i] <- tmp.dens#
    }#
    ## idenitfy the maximum density & corresponding height#
    pdens   <- data.frame(h=h.vec, den=dens.vec)#
    pdmax   <- max(dens.vec)#
    hmax    <- h.vec[dens.vec == pdmax]#
    ## isolate cluster memebers#
    clust.ids   <- cutree(myHclust, h=hmax)#
    clust.uniq  <- unique(clust.ids)#
    clust.num   <- length(clust.uniq)#
    clust.list  <- list()#
    clust.cnt   <- 1#
    for (i in 1:clust.num) {#
        tmp.clust   <- clust.uniq[i]#
        tmp.idx     <- e.idx[which(as.vector(lm.dens$clust.ids) == tmp.clust)]#
        tmp.memb    <- union(get.edgelist(myIgraph)[tmp.idx,1], get.edgelist(myIgraph)[tmp.idx,2])#
        if (length(tmp.memb) >= 3) {#
            clust.list[[clust.cnt]] <- tmp.memb#
            clust.cnt   <- clust.cnt + 1#
        }#
    }#
    return(list(pdens=pdens, pdmax=pdmax, hmax=hmax, clust.ids=clust.ids, clust.list=clust.list))#
}
a <- calcPartitionDensity(lm.clust, lm.igraph)
a
calcPartitionDensity    <- function(myHclust, myIgraph)#
{#
    h.vec       <- unique(myHclust$height)#
    h.num       <- length(h.vec)#
    e.num       <- nrow(get.edgelist(myIgraph))#
    e.idx       <- 1:e.num#
    ## matrix to hold the identify of group members at each height#
    clust.vec   <- vector(, length=h.num)#
    dens.vec    <- vector(, length=h.num)#
    ## loop each height and compute the partition density#
    for (i in 1:h.num) {#
        clust.vec     <- as.vector(cutree(myHclust, h=h.vec[i]))#
        groups.uniq   <- unique(clust.vec)#
        groups.num    <- length(groups.uniq)#
        tmp.dens      <- 0#
        ## loop over all groups at a height and compute the density#
        for (j in 1:groups.num) {#
            ## identify location of the group memebers#
            tmp.idx     <- which(clust.vec == groups.uniq[j])#
            tmp.memb    <- union(get.edgelist(myIgraph)[tmp.idx,1], get.edgelist(myIgraph)[tmp.idx,2])#
            ## compute the number of nodes and edges in the group#
            tmp.mc      <- length(tmp.idx)#
            tmp.nc      <- length(tmp.memb)#
            ## by convention, clusers with two nodes has a density of 0#
            if (tmp.nc > 2) {#
                tmp.dens    <- tmp.dens + 2*tmp.mc*(tmp.mc - (tmp.nc-1))/(e.num*(tmp.nc-2)*(tmp.nc-1))#
            }#
        }#
        dens.vec[i] <- tmp.dens#
    }#
    ## idenitfy the maximum density & corresponding height#
    pdens   <- data.frame(h=h.vec, den=dens.vec)#
    pdmax   <- max(dens.vec)#
    hmax    <- h.vec[dens.vec == pdmax]#
    ## isolate cluster memebers#
    clust.ids   <- cutree(myHclust, h=hmax)#
    clust.uniq  <- unique(clust.ids)#
    clust.num   <- length(clust.uniq)#
    clust.list  <- list()#
    clust.cnt   <- 1#
    for (i in 1:clust.num) {#
        tmp.clust   <- clust.uniq[i]#
        tmp.idx     <- e.idx[which(as.vector(myHclust$clust.ids) == tmp.clust)]#
        tmp.memb    <- union(get.edgelist(myIgraph)[tmp.idx,1], get.edgelist(myIgraph)[tmp.idx,2])#
        if (length(tmp.memb) >= 3) {#
            clust.list[[clust.cnt]] <- tmp.memb#
            clust.cnt   <- clust.cnt + 1#
        }#
    }#
    return(list(pdens=pdens, pdmax=pdmax, hmax=hmax, clust.ids=clust.ids, clust.list=clust.list))#
}
a <- calcPartitionDensity(lm.clust, lm.igraph)
a
calcPartitionDensity    <- function(myHclust, myIgraph)#
{#
    h.vec       <- unique(myHclust$height)#
    h.num       <- length(h.vec)#
    e.num       <- nrow(get.edgelist(myIgraph))#
    e.idx       <- 1:e.num#
    ## matrix to hold the identify of group members at each height#
    clust.vec   <- vector(, length=h.num)#
    dens.vec    <- vector(, length=h.num)#
    ## loop each height and compute the partition density#
    for (i in 1:h.num) {#
        clust.vec     <- as.vector(cutree(myHclust, h=h.vec[i]))#
        groups.uniq   <- unique(clust.vec)#
        groups.num    <- length(groups.uniq)#
        tmp.dens      <- 0#
        ## loop over all groups at a height and compute the density#
        for (j in 1:groups.num) {#
            ## identify location of the group memebers#
            tmp.idx     <- which(clust.vec == groups.uniq[j])#
            tmp.memb    <- union(get.edgelist(myIgraph)[tmp.idx,1], get.edgelist(myIgraph)[tmp.idx,2])#
            ## compute the number of nodes and edges in the group#
            tmp.mc      <- length(tmp.idx)#
            tmp.nc      <- length(tmp.memb)#
            ## by convention, clusers with two nodes has a density of 0#
            if (tmp.nc > 2) {#
                tmp.dens    <- tmp.dens + 2*tmp.mc*(tmp.mc - (tmp.nc-1))/(e.num*(tmp.nc-2)*(tmp.nc-1))#
            }#
        }#
        dens.vec[i] <- tmp.dens#
    }#
    ## idenitfy the maximum density & corresponding height#
    pdens   <- data.frame(h=h.vec, den=dens.vec)#
    pdmax   <- max(dens.vec)#
    hmax    <- h.vec[dens.vec == pdmax]#
    ## isolate cluster memebers#
    clust.ids   <- cutree(myHclust, h=hmax)#
    clust.uniq  <- unique(clust.ids)#
    clust.num   <- length(clust.uniq)#
    clust.list  <- list()#
    clust.cnt   <- 1#
    for (i in 1:clust.num) {#
        tmp.clust   <- clust.uniq[i]#
        tmp.idx     <- e.idx[which(as.vector(clust.ids) == tmp.clust)]#
        tmp.memb    <- union(get.edgelist(myIgraph)[tmp.idx,1], get.edgelist(myIgraph)[tmp.idx,2])#
        if (length(tmp.memb) >= 3) {#
            clust.list[[clust.cnt]] <- tmp.memb#
            clust.cnt   <- clust.cnt + 1#
        }#
    }#
    return(list(pdens=pdens, pdmax=pdmax, hmax=hmax, clust.ids=clust.ids, clust.list=clust.list))#
}
a <- calcPartitionDensity(lm.clust, lm.igraph)
a
calcPartitionDensity    <- function(myHclust, myIgraph)#
{#
    h.vec       <- unique(myHclust$height)#
    h.num       <- length(h.vec)#
    e.num       <- nrow(get.edgelist(myIgraph))#
    e.idx       <- 1:e.num#
    ## matrix to hold the identify of group members at each height#
    clust.vec   <- vector(, length=h.num)#
    dens.vec    <- vector(, length=h.num)#
    ## loop each height and compute the partition density#
    for (i in 1:h.num) {#
        clust.vec     <- as.vector(cutree(myHclust, h=h.vec[i]))#
        groups.uniq   <- unique(clust.vec)#
        groups.num    <- length(groups.uniq)#
        tmp.dens      <- 0#
        ## loop over all groups at a height and compute the density#
        for (j in 1:groups.num) {#
            ## identify location of the group memebers#
            tmp.idx     <- which(clust.vec == groups.uniq[j])#
            tmp.memb    <- union(get.edgelist(myIgraph)[tmp.idx,1], get.edgelist(myIgraph)[tmp.idx,2])#
            ## compute the number of nodes and edges in the group#
            tmp.mc      <- length(tmp.idx)#
            tmp.nc      <- length(tmp.memb)#
            ## by convention, clusers with two nodes has a density of 0#
            if (tmp.nc > 2) {#
                tmp.dens    <- tmp.dens + 2*tmp.mc*(tmp.mc - (tmp.nc-1))/(e.num*(tmp.nc-2)*(tmp.nc-1))#
            }#
        }#
        dens.vec[i] <- tmp.dens#
    }#
    ## idenitfy the maximum density & corresponding height#
    pdens   <- data.frame(h=h.vec, den=dens.vec)#
    pdmax   <- max(dens.vec)#
    hmax    <- h.vec[dens.vec == pdmax]#
    ## isolate cluster memebers#
    clust.ids   <- cutree(myHclust, h=hmax)#
    clust.uniq  <- unique(clust.ids)#
    clust.num   <- length(clust.uniq)#
    clust.list  <- list()#
    clust.cnt   <- 1#
    for (i in 1:clust.num) {#
        tmp.clust   <- clust.uniq[i]#
        tmp.idx     <- e.idx[which(clust.ids == tmp.clust)]#
        tmp.memb    <- union(get.edgelist(myIgraph)[tmp.idx,1], get.edgelist(myIgraph)[tmp.idx,2])#
        if (length(tmp.memb) >= 3) {#
            clust.list[[clust.cnt]] <- tmp.memb#
            clust.cnt   <- clust.cnt + 1#
        }#
    }#
    return(list(pdens=pdens, pdmax=pdmax, hmax=hmax, clust.ids=clust.ids, clust.list=clust.list))#
}
a <- calcPartitionDensity(lm.clust, lm.igraph)
a
myHclust <- lm.dens
myHclust <- lm.clust
myIgraph <- lm.igraph
h.vec       <- unique(myHclust$height)#
    h.num       <- length(h.vec)#
    e.num       <- nrow(get.edgelist(myIgraph))#
    e.idx       <- 1:e.num#
    ## matrix to hold the identify of group members at each height#
    clust.vec   <- vector(, length=h.num)#
    dens.vec    <- vector(, length=h.num)#
    ## loop each height and compute the partition density#
    for (i in 1:h.num) {#
        clust.vec     <- as.vector(cutree(myHclust, h=h.vec[i]))#
        groups.uniq   <- unique(clust.vec)#
        groups.num    <- length(groups.uniq)#
        tmp.dens      <- 0#
        ## loop over all groups at a height and compute the density#
        for (j in 1:groups.num) {#
            ## identify location of the group memebers#
            tmp.idx     <- which(clust.vec == groups.uniq[j])#
            tmp.memb    <- union(get.edgelist(myIgraph)[tmp.idx,1], get.edgelist(myIgraph)[tmp.idx,2])#
            ## compute the number of nodes and edges in the group#
            tmp.mc      <- length(tmp.idx)#
            tmp.nc      <- length(tmp.memb)#
            ## by convention, clusers with two nodes has a density of 0#
            if (tmp.nc > 2) {#
                tmp.dens    <- tmp.dens + 2*tmp.mc*(tmp.mc - (tmp.nc-1))/(e.num*(tmp.nc-2)*(tmp.nc-1))#
            }#
        }#
        dens.vec[i] <- tmp.dens#
    }#
    ## idenitfy the maximum density & corresponding height#
    pdens   <- data.frame(h=h.vec, den=dens.vec)#
    pdmax   <- max(dens.vec)#
    hmax    <- h.vec[dens.vec == pdmax]#
    ## isolate cluster memebers#
    clust.ids   <- cutree(myHclust, h=hmax)#
    clust.uniq  <- unique(clust.ids)#
    clust.num   <- length(clust.uniq)#
    clust.list  <- list()
clust.ids
table(clust.ids)
names(table(clust.ids))
as.integer(names(table(clust.ids)))
as.vector(clust.ids)
unique(clust.ids)
clust.num
tmp.clust   <- clust.uniq[i]
tmp.clust
i
i <- 1
tmp.clust   <- clust.uniq[i]
tmp.clust
i <- 2
tmp.clust   <- clust.uniq[i]
tmp.clust
which(clust.ids == tmp.clust)
e.idx
e.idx[which(clust.ids == tmp.clust)]
tmp.memb    <- union(get.edgelist(myIgraph)[tmp.idx,1], get.edgelist(myIgraph)[tmp.idx,2])
tmp.memb
get.edgelist(myIgraph)
tmp.idx     <- e.idx[which(clust.ids == tmp.clust)]#
        tmp.memb    <- union(get.edgelist(myIgraph)[tmp.idx,1], get.edgelist(myIgraph)[tmp.idx,2])
tmp.idx
tmp.memb
i <- 47
tmp.clust   <- clust.uniq[i]#
        tmp.idx     <- e.idx[which(clust.ids == tmp.clust)]#
        tmp.memb    <- union(get.edgelist(myIgraph)[tmp.idx,1], get.edgelist(myIgraph)[tmp.idx,2])
tmp.clust
tmp.idx
tmp.memb
get.edgelist(myIgraph)[tmp.idx,1]
get.edgelist(myIgraph)[tmp.idx,2]
length(tmp.idx)
lm.lc$clusters
tmp.idx
## isolate cluster memebers#
    clust.ids   <- cutree(myHclust, h=hmax)#
    clust.uniq  <- unique(clust.ids)#
    clust.num   <- length(clust.uniq)#
    clust.list  <- list()#
    clust.cnt   <- 1#
    for (i in 1:clust.num) {#
        tmp.clust   <- clust.uniq[i]#
        tmp.idx     <- e.idx[which(clust.ids == tmp.clust)]#
        if (length(tmp.idx) <= 3) {#
            tmp.memb    <- union(get.edgelist(myIgraph)[tmp.idx,1], get.edgelist(myIgraph)[tmp.idx,2])#
            if (tmp.memb > 2) {#
                clust.list[[clust.cnt]] <- tmp.idx#
                clust.cnt   <- clust.cnt + 1#
            }#
        } else {#
            clust.list[[clust.cnt]] <- tmp.idx#
            clust.cnt   <- clust.cnt + 1#
        }#
    }
warning()
warnings()
## isolate cluster memebers#
    clust.ids   <- cutree(myHclust, h=hmax)#
    clust.uniq  <- unique(clust.ids)#
    clust.num   <- length(clust.uniq)#
    clust.list  <- list()#
    clust.cnt   <- 1
i <- 57
i <- 47
tmp.clust   <- clust.uniq[i]#
        tmp.idx     <- e.idx[which(clust.ids == tmp.clust)]
tmp.idx
if (length(tmp.idx) <= 3) {#
            tmp.memb    <- union(get.edgelist(myIgraph)[tmp.idx,1], get.edgelist(myIgraph)[tmp.idx,2])#
            if (tmp.memb > 2) {#
                clust.list[[clust.cnt]] <- tmp.idx#
                clust.cnt   <- clust.cnt + 1#
            }#
        } else {#
            clust.list[[clust.cnt]] <- tmp.idx#
            clust.cnt   <- clust.cnt + 1#
        }
clust.list[[clust.cnt]]
clust.list[[1]]
clust.cnt   <- 1#
    for (i in 1:clust.num) {#
        tmp.clust   <- clust.uniq[i]#
        tmp.idx     <- e.idx[which(clust.ids == tmp.clust)]#
        if (length(tmp.idx) <= 3) {#
            tmp.memb    <- union(get.edgelist(myIgraph)[tmp.idx,1], get.edgelist(myIgraph)[tmp.idx,2])#
            if (tmp.memb > 2) {#
                clust.list[[clust.cnt]] <- tmp.idx#
                clust.cnt   <- clust.cnt + 1#
            }#
        } else {#
            clust.list[[clust.cnt]] <- tmp.idx#
            clust.cnt   <- clust.cnt + 1#
        }#
    }
i <- 1
tmp.clust   <- clust.uniq[i]#
        tmp.idx     <- e.idx[which(clust.ids == tmp.clust)]
tmp.clust
tmp.idx
clust.cnt   <- 1#
    for (i in 1:clust.num) {#
        tmp.clust   <- clust.uniq[i]#
        tmp.idx     <- e.idx[which(clust.ids == tmp.clust)]#
        if (length(tmp.idx) > 1) {#
            if (length(tmp.idx) %in% c(2,3)) {#
                tmp.memb    <- union(get.edgelist(myIgraph)[tmp.idx,1], get.edgelist(myIgraph)[tmp.idx,2])#
                clust.list[[clust.cnt]] <- tmp.idx#
                clust.cnt   <- clust.cnt + 1#
            } else {#
                clust.list[[clust.cnt]] <- tmp.idx#
                clust.cnt   <- clust.cnt + 1#
            }#
        }#
    }
clust.list
clust.cnt   <- 1#
    for (i in 1:clust.num) {#
        tmp.clust   <- clust.uniq[i]#
        tmp.idx     <- e.idx[which(clust.ids == tmp.clust)]#
        tmp.memb    <- union(get.edgelist(myIgraph)[tmp.idx,1], get.edgelist(myIgraph)[tmp.idx,2])#
        if (length(tmp.memb) >= 3) {#
            clust.list[[clust.cnt]] <- tmp.idx#
            clust.cnt   <- clust.cnt + 1#
        }#
    }
clust.list
tmp.memb
length(tmp.memb)
## isolate cluster memebers#
    clust.ids   <- cutree(myHclust, h=hmax)#
    clust.uniq  <- unique(clust.ids)#
    clust.num   <- length(clust.uniq)#
    clust.list  <- list()#
    clust.cnt   <- 1#
    for (i in 1:clust.num) {#
        tmp.clust   <- clust.uniq[i]#
        tmp.idx     <- e.idx[which(clust.ids == tmp.clust)]#
        tmp.memb    <- union(get.edgelist(myIgraph)[tmp.idx,1], get.edgelist(myIgraph)[tmp.idx,2])#
        if (length(tmp.memb) >= 3) {#
            clust.list[[clust.cnt]] <- tmp.idx#
            clust.cnt   <- clust.cnt + 1#
        }#
    }
clust.list
## isolate cluster memebers#
    clust.ids   <- cutree(myHclust, h=hmax)#
    clust.uniq  <- unique(clust.ids)#
    clust.num   <- length(clust.uniq)#
    clust.list  <- list()#
    clust.cnt   <- 1#
    for (i in 1:clust.num) {#
        tmp.clust   <- clust.uniq[i]#
        tmp.idx     <- e.idx[which(clust.ids == tmp.clust)]#
        tmp.memb    <- union(get.edgelist(myIgraph)[tmp.idx,1], get.edgelist(myIgraph)[tmp.idx,2])#
        if ( length(tmp.idx) >= 3 ) {#
            clust.list[[clust.cnt]] <- tmp.idx#
            clust.cnt   <- clust.cnt + 1#
        }#
    }
clust.list
lm.lc$clusters
lapply(lm.lc$clusters, length)
as.vector(lapply(lm.lc$clusters, length))
unlist(lapply(lm.lc$clusters, length))
##------------------------------------------------------------------#
## The purpose of this script is to re-create an example set of#
## clusters.  The example (the Les Miserables characters) set of#
## edges is taken from Ahn, and there is an R package that will#
## reproduce that results (linkcomm()).  I want to reproduce it#
## as well because I will be modifying the basic result (i.e.,#
## a similarity matrix to reproduce the Ye [?] et al. paper.#
##------------------------------------------------------------------#
#
##------------------------------------------------------------------#
## Load libraries#
##------------------------------------------------------------------#
library(igraph)                 ## contains graph functions#
library(linkcomm)               ## contains link community functions#
library(dendextend)             ## contains dendrogram functions#
library(caTools)#
librart(gdata)#
#
##------------------------------------------------------------------#
## Clear the workspace#
##------------------------------------------------------------------#
rm(list=ls())#
#
##------------------------------------------------------------------#
## Load utility functions#
##------------------------------------------------------------------#
source("/Users/alexstephens/Development/kaggle/social_circle/k_soc/00_Utilities.r")#
##------------------------------------------------------------------#
## Benchmark: Les Miserables characters connected graph#
##------------------------------------------------------------------#
#
## load the raw dataset (from linkcomm())#
lm <- lesmiserables#
#
##------------------------------------------------------------------#
## Step 1:  This is somewhat redundant, but translate the Les Mis#
## factor/edge list into the egonet structure that I've loaded#
## from the kaggle competition.#
##------------------------------------------------------------------#
#
## convert the data of factors into characters#
tmp.lm <- convert.magic(lm, c("V1","V2"), c("character","character"))#
#
## map character names to integers#
nodes_l.uniq    <- unique(tmp.lm$V1)#
nodes_r.uniq    <- unique(tmp.lm$V2)#
characters.uniq <- union(nodes_l.uniq, nodes_r.uniq)#
characters.ids  <- 1:length(characters.uniq)#
#
## define the egonet#
lm.egonet  <- list()#
#
## load the egonet#
for (i in 1:length(nodes_l.uniq)) {#
    ## get a vertex & assign an id#
    tmp.node    <- nodes_l.uniq[i]#
    tmp.id      <- characters.ids[ which(characters.uniq == tmp.node)]#
    char.id     <- paste("ID_",tmp.id,sep="")#
    ## get the list of characters (and their ids) associated with this vertex#
    lm.egonet[[char.id]] <- paste("ID_", characters.ids[ which(characters.uniq %in% tmp.lm$V2[which(tmp.lm$V1 == tmp.node)]) ], sep="")#
}#
#
##------------------------------------------------------------------#
## Step 2:  At this point, the Les Mis data are in a format that#
## is similar to the loaded kaggle data format. Load the raw data#
## into an igraph object#
##------------------------------------------------------------------#
lm.igraph   <- convEgonetListToIgraphObject(lm.egonet)#
##------------------------------------------------------------------#
## Step 3:  Compute the dissimilarity measure amongst the clusters.#
## The similarity measure is the Jaccard coefficient. The Jaccard#
## *distance* is 1 minus the Jaccard coefficient.#
##------------------------------------------------------------------#
#
lm.sim      <- calcSimilarityMatrix(lm.igraph)  ## similarity matrix#
lm.dis      <- 1 - lm.sim                       ## jaccard distance#
#
##------------------------------------------------------------------#
## Step 3:  Compute the cluster#
##------------------------------------------------------------------#
#
## create a distance object from the dissimilarity matrix#
lm.dist     <- as.dist(lm.dis)#
#
## compute a cluster#
lm.clust    <- hclust(lm.dist, method="single")#
lm.dend     <- as.dendrogram(lm.clust)#
##------------------------------------------------------------------#
## Step 4:  Verify cluster output using linkcomm() [ok]#
##------------------------------------------------------------------#
## use linkcomm() to compute the cluster#
lm.lc       <- getLinkCommunities(get.data.frame(lm.igraph,"edges"), hcmethod="single")#
comp.clust  <- cbind(lm.lc$hclust$height, lm.clust$height, lm.lc$hclust$height-lm.clust$height)#
##------------------------------------------------------------------#
## Step 5:  Calculate the partition density#
##------------------------------------------------------------------#
#
lm.dens <- calcPartitionDensity(lm.clust, lm.igraph)
lm.dens
q()
##------------------------------------------------------------------#
## Load libraries#
##------------------------------------------------------------------#
library(data.table)#
library(caret)#
library(foreach)#
library(doMC)#
#
##------------------------------------------------------------------#
## register cores#
##------------------------------------------------------------------#
registerDoMC(4)#
#
##------------------------------------------------------------------#
## Clear the workspace#
##------------------------------------------------------------------#
rm(list=ls())
library(caret)
library(tcltk)
library(tcltk2)
q()
library(caret)
q()
library(caret)
q()
library(caret)
library(tcltk)
library(caret)
q()
library(caret)
q()
##------------------------------------------------------------------#
## Clear the workspace#
##------------------------------------------------------------------#
rm(list=ls())#
#
##------------------------------------------------------------------#
## Load data#
##------------------------------------------------------------------#
#
## 6max simulation data#
setwd("/Users/alexstephens/Development/poker/omaha_hi/data/simulations")#
load("hotColdEquity_6max_OmahiHi_AllHands.Rdata")#
#
## 6max hand attributes#
setwd("/Users/alexstephens/Development/poker/omaha_hi/data/pptoo/OmahaHi")#
load("ppt_plo_handrankings_06handed.Rdata")
ls()
head(tmp.res)
names(plo_6max.list)
###
col.idx <- which(colnames(res.mat)=="30%")#
row.idx <- which(res.mat[,col.idx] >= 0.50)#
#
hand.idx    <- rownames(res.mat)[row.idx]#
#
hand.attr   <- data.frame(  plo_6max.list[["hd"]][which( plo_6max.list[["hd"]]$hand %in% hand.idx),],#
                            equity=res.mat[row.idx,col.idx] )
head(hand.attr)
q()
